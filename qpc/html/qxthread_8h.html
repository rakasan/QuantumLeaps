<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: qxthread.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a id="logo" title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img src="img/logo_ql.png" alt="Quantum Leaps" style="vertical-align:top; border:none;">
  </a>
  <span id="projectname">QP/C</span>
  <span id="projectnumber">6.9.1</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('qxthread_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">qxthread.h File Reference<div class="ingroups"><a class="el" href="group__qxk.html">QXK</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>QXK/C eXtended (blocking) thread.
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="qxthread_8h__dep__incl.png" border="0" usemap="#aqxthread_8hdep" alt=""/></div>
</div>
</div>
<p><a href="qxthread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_x_thread.html">QXThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">eXtended (blocking) thread of the QXK preemptive kernel  <a href="struct_q_x_thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_q_x_semaphore"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a></td></tr>
<tr class="memdesc:struct_q_x_semaphore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counting Semaphore of the QXK preemptive kernel.  <a href="qxthread_8h.html#struct_q_x_semaphore">More...</a><br /></td></tr>
<tr class="separator:struct_q_x_semaphore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_q_x_mutex"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a></td></tr>
<tr class="memdesc:struct_q_x_mutex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking Mutex the QXK preemptive kernel.  <a href="qxthread_8h.html#struct_q_x_mutex">More...</a><br /></td></tr>
<tr class="separator:struct_q_x_mutex"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3a257074a0f50871ab5e93fb1b761627"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a3a257074a0f50871ab5e93fb1b761627">QXTHREAD_START</a>(me_,  prio_,  qSto_,  qLen_,  stkSto_,  stkSize_,  par_)</td></tr>
<tr class="memdesc:a3a257074a0f50871ab5e93fb1b761627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphically start an extended thread.  <a href="qxthread_8h.html#a3a257074a0f50871ab5e93fb1b761627">More...</a><br /></td></tr>
<tr class="separator:a3a257074a0f50871ab5e93fb1b761627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008bc4f0ee9b08eba5cb71ef2cef84fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a008bc4f0ee9b08eba5cb71ef2cef84fa">QXTHREAD_POST_X</a>(me_,  e_,  margin_,  sender_)&#160;&#160;&#160;    <a class="el" href="struct_q_active.html#a766856b24aa5163b7ca90bc3432f1e3e">QACTIVE_POST_X</a>(&amp;(me_)-&gt;super, (e_), (margin_), (sender_))</td></tr>
<tr class="separator:a008bc4f0ee9b08eba5cb71ef2cef84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abace4abc24887d0adaadb26642133cfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#abace4abc24887d0adaadb26642133cfd">QXTHREAD_NO_TIMEOUT</a>&#160;&#160;&#160;((<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)0)</td></tr>
<tr class="memdesc:abace4abc24887d0adaadb26642133cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">no-timeout special timeout value when blocking on queues or semaphores  <a href="qxthread_8h.html#abace4abc24887d0adaadb26642133cfd">More...</a><br /></td></tr>
<tr class="separator:abace4abc24887d0adaadb26642133cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af521d2ff3cfa6071f3c53ecd1bc38acc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_q_active_vtable.html">QActiveVtable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#af521d2ff3cfa6071f3c53ecd1bc38acc">QXThreadVtable</a></td></tr>
<tr class="memdesc:af521d2ff3cfa6071f3c53ecd1bc38acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Table for the <a class="el" href="struct_q_x_thread.html" title="eXtended (blocking) thread of the QXK preemptive kernel">QXThread</a> class (inherited from <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>)  <a href="qxthread_8h.html#af521d2ff3cfa6071f3c53ecd1bc38acc">More...</a><br /></td></tr>
<tr class="separator:af521d2ff3cfa6071f3c53ecd1bc38acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8307d81827e59120494adddde980bf7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a8307d81827e59120494adddde980bf7c">QXThread_ctor</a> (<a class="el" href="struct_q_x_thread.html">QXThread</a> *const me, <a class="el" href="qep_8h.html#ad9869d988b94fb3d5cdc1c6c07e5f6d6">QXThreadHandler</a> handler, <a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> tickRate)</td></tr>
<tr class="memdesc:a8307d81827e59120494adddde980bf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor of an extended-thread  <a href="qxthread_8h.html#a8307d81827e59120494adddde980bf7c">More...</a><br /></td></tr>
<tr class="separator:a8307d81827e59120494adddde980bf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3359902949e88279aea2760bb6c41e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a3359902949e88279aea2760bb6c41e32">QXThread_delay</a> (<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const nTicks)</td></tr>
<tr class="memdesc:a3359902949e88279aea2760bb6c41e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">delay (block) the current extended thread for a specified # ticks  <a href="qxthread_8h.html#a3359902949e88279aea2760bb6c41e32">More...</a><br /></td></tr>
<tr class="separator:a3359902949e88279aea2760bb6c41e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77e9607b3a59a6b655d8635d83db3e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#ab77e9607b3a59a6b655d8635d83db3e4">QXThread_delayCancel</a> (<a class="el" href="struct_q_x_thread.html">QXThread</a> *const me)</td></tr>
<tr class="memdesc:ab77e9607b3a59a6b655d8635d83db3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">cancel the delay  <a href="qxthread_8h.html#ab77e9607b3a59a6b655d8635d83db3e4">More...</a><br /></td></tr>
<tr class="separator:ab77e9607b3a59a6b655d8635d83db3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eabb49cae5e3922fb7d020eecbaee82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_evt.html">QEvt</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a3eabb49cae5e3922fb7d020eecbaee82">QXThread_queueGet</a> (<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const nTicks)</td></tr>
<tr class="memdesc:a3eabb49cae5e3922fb7d020eecbaee82"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain a message from the private message queue (block if no messages)  <a href="qxthread_8h.html#a3eabb49cae5e3922fb7d020eecbaee82">More...</a><br /></td></tr>
<tr class="separator:a3eabb49cae5e3922fb7d020eecbaee82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c3d21c629fb4d36aedc9e127ae3c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a25c3d21c629fb4d36aedc9e127ae3c75">QXSemaphore_init</a> (<a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> *const me, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> count, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> max_count)</td></tr>
<tr class="memdesc:a25c3d21c629fb4d36aedc9e127ae3c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the counting semaphore  <a href="qxthread_8h.html#a25c3d21c629fb4d36aedc9e127ae3c75">More...</a><br /></td></tr>
<tr class="separator:a25c3d21c629fb4d36aedc9e127ae3c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c62839759971359392742618d58e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a93c62839759971359392742618d58e70">QXSemaphore_wait</a> (<a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> *const me, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const nTicks)</td></tr>
<tr class="memdesc:a93c62839759971359392742618d58e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait (block) on the semaphore  <a href="qxthread_8h.html#a93c62839759971359392742618d58e70">More...</a><br /></td></tr>
<tr class="separator:a93c62839759971359392742618d58e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caf16a6092236c4118adfc2ed52cb02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a7caf16a6092236c4118adfc2ed52cb02">QXSemaphore_tryWait</a> (<a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> *const me)</td></tr>
<tr class="memdesc:a7caf16a6092236c4118adfc2ed52cb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">try wait on the semaphore (non-blocking)  <a href="qxthread_8h.html#a7caf16a6092236c4118adfc2ed52cb02">More...</a><br /></td></tr>
<tr class="separator:a7caf16a6092236c4118adfc2ed52cb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a42fa24556ea0d0a203d28555b70108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a0a42fa24556ea0d0a203d28555b70108">QXSemaphore_signal</a> (<a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> *const me)</td></tr>
<tr class="memdesc:a0a42fa24556ea0d0a203d28555b70108"><td class="mdescLeft">&#160;</td><td class="mdescRight">signal (unblock) the semaphore  <a href="qxthread_8h.html#a0a42fa24556ea0d0a203d28555b70108">More...</a><br /></td></tr>
<tr class="separator:a0a42fa24556ea0d0a203d28555b70108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af446f227f03a1a71b5e064271b5da64f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f">QXMutex_init</a> (<a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> *const me, <a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> ceiling)</td></tr>
<tr class="memdesc:af446f227f03a1a71b5e064271b5da64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the QXK priority-ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a>  <a href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f">More...</a><br /></td></tr>
<tr class="separator:af446f227f03a1a71b5e064271b5da64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607a7442c8e54a46f404fcdf908cacf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8">QXMutex_lock</a> (<a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> *const me, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const nTicks)</td></tr>
<tr class="memdesc:a607a7442c8e54a46f404fcdf908cacf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">lock the QXK priority-ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a>  <a href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8">More...</a><br /></td></tr>
<tr class="separator:a607a7442c8e54a46f404fcdf908cacf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32649853d09120e9d1256f5d115acaa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#a32649853d09120e9d1256f5d115acaa8">QXMutex_tryLock</a> (<a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> *const me)</td></tr>
<tr class="memdesc:a32649853d09120e9d1256f5d115acaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to lock the QXK priority-ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a>  <a href="qxthread_8h.html#a32649853d09120e9d1256f5d115acaa8">More...</a><br /></td></tr>
<tr class="separator:a32649853d09120e9d1256f5d115acaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0780c17e77df45132fe218324bdf4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f">QXMutex_unlock</a> (<a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> *const me)</td></tr>
<tr class="memdesc:abc0780c17e77df45132fe218324bdf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">unlock the QXK priority-ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a>  <a href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f">More...</a><br /></td></tr>
<tr class="separator:abc0780c17e77df45132fe218324bdf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>QXK/C eXtended (blocking) thread. </p>

<p class="definition">Definition in file <a class="el" href="qxthread_8h_source.html">qxthread.h</a>.</p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_q_x_semaphore" id="struct_q_x_semaphore"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_q_x_semaphore">&#9670;&nbsp;</a></span>QXSemaphore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct QXSemaphore</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Counting Semaphore of the QXK preemptive kernel. </p>
<dl class="section user"><dt>Description</dt><dd><a class="el" href="qxthread_8h.html#struct_q_x_semaphore" title="Counting Semaphore of the QXK preemptive kernel.">QXSemaphore</a> is a blocking mechanism intended primarily for signaling <a class="el" href="struct_q_x_thread.html">extended threads</a>. The semaphore is initialized with the maximum count (see <a class="el" href="qxthread_8h.html#a25c3d21c629fb4d36aedc9e127ae3c75" title="initialize the counting semaphore">QXSemaphore_init()</a>), which allows you to create a binary semaphore (when the maximum count is 1) and counting semaphore when the maximum count is &gt; 1.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="qxthread_8h.html#a25c3d21c629fb4d36aedc9e127ae3c75" title="initialize the counting semaphore">QXSemaphore_init()</a></li>
<li><a class="el" href="qxthread_8h.html#a0a42fa24556ea0d0a203d28555b70108" title="signal (unblock) the semaphore">QXSemaphore_signal()</a></li>
<li><a class="el" href="qxthread_8h.html#a93c62839759971359392742618d58e70" title="wait (block) on the semaphore">QXSemaphore_wait()</a></li>
<li><a class="el" href="qxthread_8h.html#a7caf16a6092236c4118adfc2ed52cb02" title="try wait on the semaphore (non-blocking)">QXSemaphore_tryWait()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates how to instantiate and use the semaphore in your application. <div class="fragment"><div class="line"><a class="code" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> BTN_sema; <span class="comment">/* semaphore to signal a button press */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    . . .</div>
<div class="line">    <span class="comment">/* initialize the BTN_sema semaphore as binary, signaling semaphore */</span></div>
<div class="line">    <a class="code" href="qxthread_8h.html#a25c3d21c629fb4d36aedc9e127ae3c75">QXSemaphore_init</a>(&amp;BTN_sema, <span class="comment">/* pointer to semaphore to initialize */</span></div>
<div class="line">                     0U,  <span class="comment">/* initial semaphore count (singaling semaphore) */</span></div>
<div class="line">                     1U); <span class="comment">/* maximum semaphore count (binary semaphore) */</span></div>
<div class="line">    . . .</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main_threadXYZ(<a class="code" href="struct_q_x_thread.html">QXThread</a> * <span class="keyword">const</span> me) {</div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        . . .</div>
<div class="line">        <a class="code" href="qxthread_8h.html#a93c62839759971359392742618d58e70">QXSemaphore_wait</a>(&amp;BTN_sema,  <span class="comment">/* pointer to semaphore to wait on */</span></div>
<div class="line">                         <a class="code" href="qxthread_8h.html#abace4abc24887d0adaadb26642133cfd">QXTHREAD_NO_TIMEOUT</a>); <span class="comment">/* timeout for waiting */</span></div>
<div class="line">        . . .</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> GPIO_Handler(<span class="keywordtype">void</span>) {</div>
<div class="line">    . . .</div>
<div class="line">    <a class="code" href="qxthread_8h.html#a0a42fa24556ea0d0a203d28555b70108">QXSemaphore_signal</a>(&amp;BTN_sema); <span class="comment">/* pointer to semaphore to signal */</span></div>
<div class="line">    . . .</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qxthread_8h_source.html#l00183">183</a> of file <a class="el" href="qxthread_8h_source.html">qxthread.h</a>.</p>
</div><div class="dynheader">
Collaboration diagram for QXSemaphore:</div>
<div class="dyncontent">
<div class="center"><img src="struct_q_x_semaphore__coll__graph.png" border="0" usemap="#a_q_x_semaphore_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab7f603a22e6cbc0d27a31d338cad5eb6"></a><a class="el" href="qpset_8h.html#struct_q_p_set">QPSet</a></td>
<td class="fieldname">
waitSet</td>
<td class="fielddoc">
set of extended-threads waiting on this semaphore </td></tr>
<tr><td class="fieldtype">
<a id="a03dc22517930088f261552aa6318b532"></a><a class="el" href="16bit_2stdint_8h.html#a1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> volatile</td>
<td class="fieldname">
count</td>
<td class="fielddoc">
semaphore up-down counter </td></tr>
<tr><td class="fieldtype">
<a id="a7b50573c335728800d65f3fb5479f9bc"></a><a class="el" href="16bit_2stdint_8h.html#a1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a></td>
<td class="fieldname">
max_count</td>
<td class="fielddoc">
maximum value of the semaphore counter </td></tr>
</table>

</div>
</div>
<a name="struct_q_x_mutex" id="struct_q_x_mutex"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_q_x_mutex">&#9670;&nbsp;</a></span>QXMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct QXMutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Blocking Mutex the QXK preemptive kernel. </p>
<dl class="section user"><dt>Description</dt><dd><a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> is a blocking mutual exclusion mechanism that can also apply the <b>priority ceiling protocol</b> to avoid unbounded priority inversion (if initialized with a non-zero ceiling priority, see <a class="el" href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f" title="initialize the QXK priority-ceiling mutex QXMutex">QXMutex_init()</a>). In that case, <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> requires its own uinque QP priority level, which cannot be used by any thread or any other <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a>. If initialzied with zero ceiling priority, <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> does <b>not</b> use the priority ceiling protocol and does not require a unique QP priority (see <a class="el" href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f" title="initialize the QXK priority-ceiling mutex QXMutex">QXMutex_init()</a>). <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> is <b>recursive</b> (reentrant), which means that it can be locked mutiliple times (up to 255 levels) by the <em>same</em> thread without causing deadlock. <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> is primarily intended for the <a class="el" href="struct_q_x_thread.html">extened (blocking) threads</a>, but can also be used by the <a class="el" href="struct_q_active.html">basic threads</a> through the non-blocking <a class="el" href="qxthread_8h.html#a32649853d09120e9d1256f5d115acaa8" title="try to lock the QXK priority-ceiling mutex QXMutex">QXMutex_tryLock()</a> API.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> should be used in situations when at least one of the extended threads contending for the mutex blocks while holding the mutex (between the <a class="el" href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8" title="lock the QXK priority-ceiling mutex QXMutex">QXMutex_lock()</a> and <a class="el" href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f" title="unlock the QXK priority-ceiling mutex QXMutex">QXMutex_unlock()</a> operations). If no blocking is needed while holding the mutex, the more efficient non-blocking mechanism of <a class="el" href="qxk_8h.html#a5efc78d4b56e41d3da82c16c75e8887c">selective QXK scheduler locking</a> should be used instead. <a class="el" href="qxk_8h.html#a5efc78d4b56e41d3da82c16c75e8887c">Selective scheduler locking</a> is available for both <a class="el" href="struct_q_active.html">basic threads</a> and <a class="el" href="struct_q_x_thread.html">extended</a>threads", so it is applicable to situations where resources are shared among all these threads.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f" title="initialize the QXK priority-ceiling mutex QXMutex">QXMutex_init()</a></li>
<li><a class="el" href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8" title="lock the QXK priority-ceiling mutex QXMutex">QXMutex_lock()</a></li>
<li><a class="el" href="qxthread_8h.html#a32649853d09120e9d1256f5d115acaa8" title="try to lock the QXK priority-ceiling mutex QXMutex">QXMutex_tryLock()</a></li>
<li><a class="el" href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f" title="unlock the QXK priority-ceiling mutex QXMutex">QXMutex_unlock()</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates how to instantiate and use the mutex in your application. <div class="fragment"><div class="line"><a class="code" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> l_rndMutex;  <span class="comment">/* mutex to protect the random number generator */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BSP_randomSeed(<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> seed) {</div>
<div class="line">    <a class="code" href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f">QXMutex_init</a>(&amp;l_rndMutex, N_PHILO); <span class="comment">/* &lt;== initialize the mutex */</span></div>
<div class="line">    l_rnd = seed;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> BSP_random(<span class="keywordtype">void</span>) { <span class="comment">/* a very cheap pseudo-random-number generator */</span></div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> rnd;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8">QXMutex_lock</a>(&amp;l_rndMutex); <span class="comment">/* &lt;== lock the shared random seed */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* &quot;Super-Duper&quot; Linear Congruential Generator (LCG) */</span></div>
<div class="line">    rnd = l_rnd * (3U*7U*11U*13U*23U);</div>
<div class="line">    l_rnd = rnd; <span class="comment">/* set for the next time */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f">QXMutex_unlock</a>(&amp;l_rndMutex); <span class="comment">/* &lt;== unlock the shared random seed */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> rnd;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qxthread_8h_source.html#l00245">245</a> of file <a class="el" href="qxthread_8h_source.html">qxthread.h</a>.</p>
</div><div class="dynheader">
Collaboration diagram for QXMutex:</div>
<div class="dyncontent">
<div class="center"><img src="struct_q_x_mutex__coll__graph.png" border="0" usemap="#a_q_x_mutex_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab7f603a22e6cbc0d27a31d338cad5eb6"></a><a class="el" href="qpset_8h.html#struct_q_p_set">QPSet</a></td>
<td class="fieldname">
waitSet</td>
<td class="fielddoc">
set of extended-threads waiting on this mutex </td></tr>
<tr><td class="fieldtype">
<a id="a68e931bdcab495826d4d0ec5f5f90941"></a><a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> volatile</td>
<td class="fieldname">
lockNest</td>
<td class="fielddoc">
lock-nesting up-down counter </td></tr>
<tr><td class="fieldtype">
<a id="a76f6eb37479292d31c97162e60ccb78e"></a><a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> volatile</td>
<td class="fieldname">
holderPrio</td>
<td class="fielddoc">
priority of the lock holder thread </td></tr>
<tr><td class="fieldtype">
<a id="aeae41d9c3a19d945957a534257e30792"></a><a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></td>
<td class="fieldname">
ceiling</td>
<td class="fielddoc">
prioirty ceiling of this mutex </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3a257074a0f50871ab5e93fb1b761627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a257074a0f50871ab5e93fb1b761627">&#9670;&nbsp;</a></span>QXTHREAD_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QXTHREAD_START</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">qSto_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">qLen_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stkSto_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stkSize_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">par_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                      \</div>
<div class="line">    Q_ASSERT((me_)-&gt;super.super.vptr);                                    \</div>
<div class="line">    ((*((<a class="code" href="struct_q_active_vtable.html">QActiveVtable</a> <span class="keyword">const</span> *)((me_)-&gt;super.super.vptr))-&gt;start)(        \</div>
<div class="line">        &amp;(me_)-&gt;super, (prio_), (<a class="code" href="struct_q_evt.html">QEvt</a> <span class="keyword">const</span> **)(qSto_), (qLen_),          \</div>
<div class="line">        (stkSto_), (stkSize_), (par_)));                                  \</div>
<div class="line">} <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Polymorphically start an extended thread. </p>
<dl class="section user"><dt>Description</dt><dd>Starts execution of the thread and registers the thread with the framework.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me_</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio_</td><td>priority of the extended-thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qSto_</td><td>pointer to the storage for the ring buffer of the message queue (possibly NULL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qLen_</td><td>length of the message queue [events] (possibly 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stkSto_</td><td>pointer to the stack storage (required) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stkSize_</td><td>stack size [bytes] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">par_</td><td>pointer to the additional port-specific parameter(s) (might be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="qpc_8h.html">qpc.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="qassert_8h.html#a27042866331f49c9e9ff4f3ef459eaaf">Q_DEFINE_THIS_FILE</a></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    . . .</div>
<div class="line">    <span class="comment">/* stack for the QXK&#39;s idle thread */</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="16bit_2stdint_8h.html#aaa5d1cd013383c889537491c3cfd9aad">uint64_t</a> idleStackSto[32];</div>
<div class="line"> </div>
<div class="line">    Test_ctor();  <span class="comment">/* instantiate the Test &quot;naked&quot; thread */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a>();    <span class="comment">/* initialize the framework */</span></div>
<div class="line">    BSP_init();   <span class="comment">/* initialize the Board Support Package */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialize QXK... */</span></div>
<div class="line">    QXK_init(idleStackSto, <span class="keyword">sizeof</span>(idleStackSto));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialize publish-subscribe... */</span></div>
<div class="line">    <a class="code" href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">QF_psInit</a>(subscrSto, <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(subscrSto));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialize event pools... */</span></div>
<div class="line">    <a class="code" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a>(smlPoolSto, <span class="keyword">sizeof</span>(smlPoolSto), <span class="keyword">sizeof</span>(smlPoolSto[0]));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* start the active objects (basic-threads)... */</span></div>
<div class="line">    <a class="code" href="struct_q_active.html#a3123ef03f5d66d866da12c736ac574b0">QACTIVE_START</a>(AO_Table,              <span class="comment">/* AO to start */</span></div>
<div class="line">                  N_PHILO + 2U,          <span class="comment">/* QP priority of the AO */</span></div>
<div class="line">                  tableQueueSto,         <span class="comment">/* event queue storage */</span></div>
<div class="line">                  <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(tableQueueSto),  <span class="comment">/* queue length [events] */</span></div>
<div class="line">                  tableStackSto,         <span class="comment">/* stack storage */</span></div>
<div class="line">                  <span class="keyword">sizeof</span>(tableStackSto), <span class="comment">/* stack size [bytes] */</span></div>
<div class="line">                  (<span class="keywordtype">void</span> *)0);            <span class="comment">/* initialization param */</span></div>
<div class="line">    . . .</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* start the extended-threads... */</span></div>
<div class="line">    <a class="code" href="qxthread_8h.html#a3a257074a0f50871ab5e93fb1b761627">QXTHREAD_START</a>(XT_Test,              <span class="comment">/* Thread to start */</span></div>
<div class="line">                  10U,                   <span class="comment">/* QP priority of the thread */</span></div>
<div class="line">                  testQueueSto,          <span class="comment">/* message queue storage */</span></div>
<div class="line">                  <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(testQueueSto),   <span class="comment">/* message length [events] */</span></div>
<div class="line">                  testStackSto,          <span class="comment">/* stack storage */</span></div>
<div class="line">                  <span class="keyword">sizeof</span>(testStackSto),  <span class="comment">/* stack size [bytes] */</span></div>
<div class="line">                  (<span class="keywordtype">void</span> *)0);            <span class="comment">/* initialization param */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a>(); <span class="comment">/* run the QF application */</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qxthread_8h_source.html#l00103">103</a> of file <a class="el" href="qxthread_8h_source.html">qxthread.h</a>.</p>

</div>
</div>
<a id="a008bc4f0ee9b08eba5cb71ef2cef84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008bc4f0ee9b08eba5cb71ef2cef84fa">&#9670;&nbsp;</a></span>QXTHREAD_POST_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QXTHREAD_POST_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">margin_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    <a class="el" href="struct_q_active.html#a766856b24aa5163b7ca90bc3432f1e3e">QACTIVE_POST_X</a>(&amp;(me_)-&gt;super, (e_), (margin_), (sender_))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Description</dt><dd>This macro does not assert if the queue overflows and cannot accept the event with the specified margin of free slots remaining.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me_</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the event to post </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin_</td><td>the minimum free slots in the queue, which must still be available after posting the event. The special value <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> causes asserting failure in case event allocation fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object (used in QS tracing)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the posting succeeded, and 'false' if the posting failed due to insufficient margin of free slots available in the queue.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sender_</code> parameter is actually only used when QS tracing is enabled (macro <a class="el" href="macros_8h.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined). When QS software tracing is disabled, the <a class="el" href="qxthread_8h.html#a008bc4f0ee9b08eba5cb71ef2cef84fa">QXTHREAD_POST_X()</a> macro does not pass the <code>sender_</code> argument, so the overhead of passing this extra argument is entirely avoided.</dd>
<dd>
The pointer to the sender object is not necessarily a pointer to an active object. In fact, if <a class="el" href="qxthread_8h.html#a008bc4f0ee9b08eba5cb71ef2cef84fa">QXTHREAD_POST_X()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the sender of the event.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_q_active.html">QActive</a> *AO_Table;</div>
<div class="line"> </div>
<div class="line">    . . .</div>
<div class="line">    <span class="comment">/* typically inside a state machine action */</span></div>
<div class="line">    TableEvt *pe;</div>
<div class="line">    <a class="code" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a>(pe, TableEvt, 5U, HUNGRY_SIG); <span class="comment">/* dynamic alloc, margin==5 */</span></div>
<div class="line">    <span class="keywordflow">if</span> (pe != (TableEvt *)0) {</div>
<div class="line">        pe-&gt;philNum = me-&gt;num;</div>
<div class="line">        <a class="code" href="struct_q_active.html#a766856b24aa5163b7ca90bc3432f1e3e">QACTIVE_POST_X</a>(AO_Table, &amp;pe-&gt;super, 3U, me); <span class="comment">/* margin==3 */</span></div>
<div class="line">    }</div>
<div class="line">    . . .</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qxthread_8h_source.html#l00147">147</a> of file <a class="el" href="qxthread_8h_source.html">qxthread.h</a>.</p>

</div>
</div>
<a id="abace4abc24887d0adaadb26642133cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abace4abc24887d0adaadb26642133cfd">&#9670;&nbsp;</a></span>QXTHREAD_NO_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QXTHREAD_NO_TIMEOUT&#160;&#160;&#160;((<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>no-timeout special timeout value when blocking on queues or semaphores </p>

<p class="definition">Definition at line <a class="el" href="qxthread_8h_source.html#l00160">160</a> of file <a class="el" href="qxthread_8h_source.html">qxthread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af521d2ff3cfa6071f3c53ecd1bc38acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af521d2ff3cfa6071f3c53ecd1bc38acc">&#9670;&nbsp;</a></span>QXThreadVtable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_q_active_vtable.html">QActiveVtable</a> <a class="el" href="qxthread_8h.html#af521d2ff3cfa6071f3c53ecd1bc38acc">QXThreadVtable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual Table for the <a class="el" href="struct_q_x_thread.html" title="eXtended (blocking) thread of the QXK preemptive kernel">QXThread</a> class (inherited from <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>) </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_q_x_thread.html" title="eXtended (blocking) thread of the QXK preemptive kernel">QXThread</a> inherits <a class="el" href="struct_q_active.html" title="Active Object base class (based on QHsm implementation)">QActive</a> without adding any new virtual functions and therefore, <a class="el" href="qxthread_8h.html#af521d2ff3cfa6071f3c53ecd1bc38acc" title="Virtual Table for the QXThread class (inherited from QActiveVtable)">QXThreadVtable</a> is typedef'ed as <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qxthread_8h_source.html#l00084">84</a> of file <a class="el" href="qxthread_8h_source.html">qxthread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8307d81827e59120494adddde980bf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8307d81827e59120494adddde980bf7c">&#9670;&nbsp;</a></span>QXThread_ctor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QXThread_ctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_x_thread.html">QXThread</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad9869d988b94fb3d5cdc1c6c07e5f6d6">QXThreadHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a>&#160;</td>
          <td class="paramname"><em>tickRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor of an extended-thread </p>
<dl class="section user"><dt>Description</dt><dd>Performs the first step of <a class="el" href="struct_q_x_thread.html" title="eXtended (blocking) thread of the QXK preemptive kernel">QXThread</a> initialization by assigning the thread-handler function and the tick rate at which it will handle the timeouts.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>the thread-handler function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate</td><td>the ticking rate for timeouts in this thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be called only ONCE before <a class="el" href="qxthread_8h.html#a3a257074a0f50871ab5e93fb1b761627" title="Polymorphically start an extended thread.">QXTHREAD_START()</a>.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates how to invoke <a class="el" href="qxk__xthr_8c.html#a8307d81827e59120494adddde980bf7c" title="constructor of an extended-thread">QXThread_ctor()</a> in the main() function</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="qpc_8h.html">qpc.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="qassert_8h.html#a27042866331f49c9e9ff4f3ef459eaaf">Q_DEFINE_THIS_FILE</a></div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_q_x_thread.html">QXThread</a> blinky;  <span class="comment">/* QXK extended-thread object */</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> stack_blinky[80]; <span class="comment">/* stack for the thread */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main_blinky(<a class="code" href="struct_q_x_thread.html">QXThread</a> * <span class="keyword">const</span> me) { <span class="comment">/* thread function */</span></div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        . . .</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    . . .</div>
<div class="line">    <span class="comment">/* instantiate and start blinky thread */</span></div>
<div class="line">    <a class="code" href="qxthread_8h.html#a8307d81827e59120494adddde980bf7c">QXThread_ctor</a>(&amp;blinky, &amp;main_blinky, 0); <span class="comment">/* &lt;=== ctor */</span></div>
<div class="line">    <a class="code" href="qxthread_8h.html#a3a257074a0f50871ab5e93fb1b761627">QXTHREAD_START</a>(&amp;blinky,</div>
<div class="line">                   5U, <span class="comment">/* priority */</span></div>
<div class="line">                   (<span class="keywordtype">void</span> *)0, 0, <span class="comment">/* message queue (not used) */</span></div>
<div class="line">                   stack_blinky, <span class="keyword">sizeof</span>(stack_blinky), <span class="comment">/* stack */</span></div>
<div class="line">                   (<span class="keywordtype">void</span> *)0); <span class="comment">/* extra parameter (not used) */</span></div>
<div class="line">    . . .</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a>(); <span class="comment">/* run the application */</span></div>
<div class="line">}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="qxk__xthr_8c_source.html#l00113">113</a> of file <a class="el" href="qxk__xthr_8c_source.html">qxk_xthr.c</a>.</p>

</div>
</div>
<a id="a3359902949e88279aea2760bb6c41e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3359902949e88279aea2760bb6c41e32">&#9670;&nbsp;</a></span>QXThread_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QXThread_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>nTicks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delay (block) the current extended thread for a specified # ticks </p>
<p>delay (block) the current extended thread for a specified # ticks </p>
<dl class="section pre"><dt>Precondition</dt><dd>this function must:<ul>
<li>NOT be called from an ISR;</li>
<li>be called from an extended thread;</li>
<li>the thread must NOT be already blocked on any object.</li>
</ul>
</dd>
<dd>
also: the thread must NOT be holding a scheduler lock.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__xthr_8c_source.html#l00644">644</a> of file <a class="el" href="qxk__xthr_8c_source.html">qxk_xthr.c</a>.</p>

</div>
</div>
<a id="ab77e9607b3a59a6b655d8635d83db3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77e9607b3a59a6b655d8635d83db3e4">&#9670;&nbsp;</a></span>QXThread_delayCancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QXThread_delayCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_x_thread.html">QXThread</a> *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cancel the delay </p>

<p class="definition">Definition at line <a class="el" href="qxk__xthr_8c_source.html#l00684">684</a> of file <a class="el" href="qxk__xthr_8c_source.html">qxk_xthr.c</a>.</p>

</div>
</div>
<a id="a3eabb49cae5e3922fb7d020eecbaee82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eabb49cae5e3922fb7d020eecbaee82">&#9670;&nbsp;</a></span>QXThread_queueGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_evt.html">QEvt</a> const* QXThread_queueGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>nTicks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obtain a message from the private message queue (block if no messages) </p>
<dl class="section user"><dt>Description</dt><dd>The <a class="el" href="qxk__xthr_8c.html#a3eabb49cae5e3922fb7d020eecbaee82" title="obtain a message from the private message queue (block if no messages)">QXThread_queueGet()</a> operation allows the calling extended thread to receive QP events directly into its own built-in event queue from an ISR, basic thread (AO), or another extended thread.</dd></dl>
<p>If <a class="el" href="qxk__xthr_8c.html#a3eabb49cae5e3922fb7d020eecbaee82" title="obtain a message from the private message queue (block if no messages)">QXThread_queueGet()</a> is called when no events are present in the thread's private event queue, the operation blocks the current extended thread until either an event is received, or a user-specified timeout expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nTicks</td><td>number of clock ticks (at the associated rate) to wait for the event to arrive. The value of QXTHREAD_NO_TIMEOUT indicates that no timeout will occur and the queue will block indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the event. If the pointer is not NULL, the event was delivered. Otherwise the event pointer of NULL indicates that the queue has timed out. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>this function must:<ul>
<li>NOT be called from an ISR;</li>
<li>be called from an extended thread;</li>
<li>the thread must NOT be already blocked on any object.</li>
</ul>
</dd>
<dd>
also: the thread must NOT be holding a scheduler lock.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__xthr_8c_source.html#l00453">453</a> of file <a class="el" href="qxk__xthr_8c_source.html">qxk_xthr.c</a>.</p>

</div>
</div>
<a id="a25c3d21c629fb4d36aedc9e127ae3c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c3d21c629fb4d36aedc9e127ae3c75">&#9670;&nbsp;</a></span>QXSemaphore_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QXSemaphore_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize the counting semaphore </p>
<dl class="section user"><dt>Description</dt><dd>Initializes a semaphore with the specified count and maximum count. If the semaphore is used for resource sharing, both the initial count and maximum count should be set to the number of identical resources guarded by the semaphore. If the semaphore is used as a signaling mechanism, the initial count should set to 0 and maximum count to 1 (binary semaphore).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>initial value of the semaphore counter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_count</td><td>maximum value of the semaphore counter. The purpose of the max_count is to limit the counter so that the semaphore cannot unblock more times than the maximum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="qxk__sema_8c.html#a25c3d21c629fb4d36aedc9e127ae3c75" title="initialize the counting semaphore">QXSemaphore_init()</a> must be called <b>before</b> the semaphore can be used (signaled or waited on). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>max_count must be greater than zero</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__sema_8c_source.html#l00079">79</a> of file <a class="el" href="qxk__sema_8c_source.html">qxk_sema.c</a>.</p>

</div>
</div>
<a id="a93c62839759971359392742618d58e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c62839759971359392742618d58e70">&#9670;&nbsp;</a></span>QXSemaphore_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QXSemaphore_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>nTicks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wait (block) on the semaphore </p>
<dl class="section user"><dt>Description</dt><dd>When an extended thread calls <a class="el" href="qxk__sema_8c.html#a93c62839759971359392742618d58e70" title="wait (block) on the semaphore">QXSemaphore_wait()</a> and the value of the semaphore counter is greater than 0, <a class="el" href="qxk__sema_8c.html#a93c62839759971359392742618d58e70" title="wait (block) on the semaphore">QXSemaphore_wait()</a> decrements the semaphore counter and returns (true) to its caller. However, if the value of the semaphore counter is 0, the function places the calling thread in the waiting list for the semaphore. The thread waits until the semaphore is signaled by calling <a class="el" href="qxk__sema_8c.html#a0a42fa24556ea0d0a203d28555b70108" title="signal (unblock) the semaphore">QXSemaphore_signal()</a>, or the specified timeout expires. If the semaphore is signaled before the timeout expires, QXK resumes the highest-priority extended thread waiting for the semaphore.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nTicks</td><td>number of clock ticks (at the associated rate) to wait for the semaphore. The value of QXTHREAD_NO_TIMEOUT indicates that no timeout will occur and the semaphore will wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the semaphore has been signaled and 'false' if a timeout occured.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Multiple extended threads can wait for a given semahpre. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>this function must:<ul>
<li>NOT be called from an ISR;</li>
<li>the semaphore must be initialized</li>
<li>be called from an extended thread;</li>
<li>the thread must NOT be already blocked on any object.</li>
</ul>
</dd>
<dd>
also: the thread must NOT be holding a scheduler lock.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__sema_8c_source.html#l00114">114</a> of file <a class="el" href="qxk__sema_8c_source.html">qxk_sema.c</a>.</p>

</div>
</div>
<a id="a7caf16a6092236c4118adfc2ed52cb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7caf16a6092236c4118adfc2ed52cb02">&#9670;&nbsp;</a></span>QXSemaphore_tryWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QXSemaphore_tryWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>try wait on the semaphore (non-blocking) </p>
<dl class="section user"><dt>Description</dt><dd>This function checks if the semaphore counter is greater than 0, in which case the counter is decremented.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the semaphore has count available and 'false' NOT available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function can be called from any context, including ISRs and basic threds (active objects). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the semaphore must be initialized</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__sema_8c_source.html#l00199">199</a> of file <a class="el" href="qxk__sema_8c_source.html">qxk_sema.c</a>.</p>

</div>
</div>
<a id="a0a42fa24556ea0d0a203d28555b70108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a42fa24556ea0d0a203d28555b70108">&#9670;&nbsp;</a></span>QXSemaphore_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QXSemaphore_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a> *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signal (unblock) the semaphore </p>
<dl class="section user"><dt>Description</dt><dd>If the semaphore counter value is 0 or more, it is incremented, and this function returns to its caller. If the extended threads are waiting for the semaphore to be signaled, <a class="el" href="qxk__sema_8c.html#a0a42fa24556ea0d0a203d28555b70108" title="signal (unblock) the semaphore">QXSemaphore_signal()</a> removes the highest- priority thread waiting for the semaphore from the waiting list and makes this thread ready-to-run. The QXK scheduler is then called to determine if the awakened thread is now the highest-priority thread that is ready-to-run.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' when the semaphore signaled and 'false' when the semaphore count exceeded the maximum.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A semaphore can be signaled from many places, including from ISRs, basic threads (AOs), and extended threads. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the semaphore must be initialized</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__sema_8c_source.html#l00240">240</a> of file <a class="el" href="qxk__sema_8c_source.html">qxk_sema.c</a>.</p>

</div>
</div>
<a id="af446f227f03a1a71b5e064271b5da64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af446f227f03a1a71b5e064271b5da64f">&#9670;&nbsp;</a></span>QXMutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QXMutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a>&#160;</td>
          <td class="paramname"><em>ceiling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize the QXK priority-ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> </p>
<dl class="section user"><dt>Description</dt><dd>Initialize the QXK priority ceiling mutex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ceiling</td><td>the ceiling-priotity of this mutex or zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>ceiling == 0</code> means that the priority-ceiling protocol shall <b>not</b> be used by this mutex. Such mutex will <b>not</b> change (boost) the priority of the holding thread.</dd>
<dd>
<code>ceiling &gt; 0</code> means that the priority-ceiling protocol shall be used by this mutex. Such mutex <b>will</b> boost the priority of the holding thread to the <code>ceiling</code> level for as long as the thread holds this mutex.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>When the priority-ceiling protocol is used (<code>ceiling &gt; 0</code>), the <code>ceiling</code> priority must be unused by any other thread or mutex. Also, the <code>ceiling</code> priority must be higher than priority of any thread that uses this mutex.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><a class="code" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> l_rndMutex;  <span class="comment">/* mutex to protect the random number generator */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BSP_randomSeed(<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> seed) {</div>
<div class="line">    <a class="code" href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f">QXMutex_init</a>(&amp;l_rndMutex, N_PHILO); <span class="comment">/* &lt;== initialize the mutex */</span></div>
<div class="line">    l_rnd = seed;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> BSP_random(<span class="keywordtype">void</span>) { <span class="comment">/* a very cheap pseudo-random-number generator */</span></div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> rnd;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8">QXMutex_lock</a>(&amp;l_rndMutex); <span class="comment">/* &lt;== lock the shared random seed */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* &quot;Super-Duper&quot; Linear Congruential Generator (LCG) */</span></div>
<div class="line">    rnd = l_rnd * (3U*7U*11U*13U*23U);</div>
<div class="line">    l_rnd = rnd; <span class="comment">/* set for the next time */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f">QXMutex_unlock</a>(&amp;l_rndMutex); <span class="comment">/* &lt;== unlock the shared random seed */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> rnd;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the celiling priority of the mutex must:<ul>
<li>cannot exceed the maximum <a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>;</li>
<li>the ceiling priority of the mutex must not be already in use; (QF requires priority to be <b>unique</b>).</li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__mutex_8c_source.html#l00087">87</a> of file <a class="el" href="qxk__mutex_8c_source.html">qxk_mutex.c</a>.</p>

</div>
</div>
<a id="a607a7442c8e54a46f404fcdf908cacf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607a7442c8e54a46f404fcdf908cacf8">&#9670;&nbsp;</a></span>QXMutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QXMutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>nTicks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lock the QXK priority-ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> </p>
<dl class="section user"><dt>Description</dt><dd>Lock the QXK priority ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nTicks</td><td>number of clock ticks (at the associated rate) to wait for the semaphore. The value of QXTHREAD_NO_TIMEOUT indicates that no timeout will occur and the semaphore will wait indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the mutex has been acquired and 'false' if a timeout occured.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The mutex locks are allowed to nest, meaning that the same extended thread can lock the same mutex multiple times (&lt; 255). However, each call to <a class="el" href="qxk__mutex_8c.html#a607a7442c8e54a46f404fcdf908cacf8" title="lock the QXK priority-ceiling mutex QXMutex">QXMutex_lock()</a> must be ballanced by the matching call to <a class="el" href="qxk__mutex_8c.html#abc0780c17e77df45132fe218324bdf4f" title="unlock the QXK priority-ceiling mutex QXMutex">QXMutex_unlock()</a>.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><a class="code" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> l_rndMutex;  <span class="comment">/* mutex to protect the random number generator */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BSP_randomSeed(<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> seed) {</div>
<div class="line">    <a class="code" href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f">QXMutex_init</a>(&amp;l_rndMutex, N_PHILO); <span class="comment">/* &lt;== initialize the mutex */</span></div>
<div class="line">    l_rnd = seed;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> BSP_random(<span class="keywordtype">void</span>) { <span class="comment">/* a very cheap pseudo-random-number generator */</span></div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> rnd;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8">QXMutex_lock</a>(&amp;l_rndMutex); <span class="comment">/* &lt;== lock the shared random seed */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* &quot;Super-Duper&quot; Linear Congruential Generator (LCG) */</span></div>
<div class="line">    rnd = l_rnd * (3U*7U*11U*13U*23U);</div>
<div class="line">    l_rnd = rnd; <span class="comment">/* set for the next time */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f">QXMutex_unlock</a>(&amp;l_rndMutex); <span class="comment">/* &lt;== unlock the shared random seed */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> rnd;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>this function must:<ul>
<li>NOT be called from an ISR;</li>
<li>be called from an extended thread;</li>
<li>the ceiling priority must not be used; or if used<ul>
<li>the thread priority must be below the ceiling of the mutex;</li>
</ul>
</li>
<li>the ceiling must be in range</li>
<li>the thread must NOT be already blocked on any object.</li>
</ul>
</dd>
<dd>
also: the thread must NOT be holding a scheduler lock.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__mutex_8c_source.html#l00134">134</a> of file <a class="el" href="qxk__mutex_8c_source.html">qxk_mutex.c</a>.</p>

</div>
</div>
<a id="a32649853d09120e9d1256f5d115acaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32649853d09120e9d1256f5d115acaa8">&#9670;&nbsp;</a></span>QXMutex_tryLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QXMutex_tryLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>try to lock the QXK priority-ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> </p>
<dl class="section user"><dt>Description</dt><dd>Try to lock the QXK priority ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the mutex was successfully locked and 'false' if the mutex was unavailable and was NOT locked.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function <b>can</b> be called from both basic threads (active objects) and extended threads.</dd>
<dd>
The mutex locks are allowed to nest, meaning that the same extended thread can lock the same mutex multiple times (&lt;= 225). However, each successful call to <a class="el" href="qxk__mutex_8c.html#a32649853d09120e9d1256f5d115acaa8" title="try to lock the QXK priority-ceiling mutex QXMutex">QXMutex_tryLock()</a> must be ballanced by the matching call to <a class="el" href="qxk__mutex_8c.html#abc0780c17e77df45132fe218324bdf4f" title="unlock the QXK priority-ceiling mutex QXMutex">QXMutex_unlock()</a>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>this function must:<ul>
<li>NOT be called from an ISR;</li>
<li>the calling thread must be valid;</li>
<li>the ceiling must be not used; or<ul>
<li>the thread priority must be below the ceiling of the mutex;</li>
</ul>
</li>
<li>the ceiling must be in range</li>
</ul>
</dd>
<dd>
also: the thread must NOT be holding a scheduler lock.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__mutex_8c_source.html#l00269">269</a> of file <a class="el" href="qxk__mutex_8c_source.html">qxk_mutex.c</a>.</p>

</div>
</div>
<a id="abc0780c17e77df45132fe218324bdf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0780c17e77df45132fe218324bdf4f">&#9670;&nbsp;</a></span>QXMutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QXMutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> *const&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unlock the QXK priority-ceiling mutex <a class="el" href="qxthread_8h.html#struct_q_x_mutex" title="Blocking Mutex the QXK preemptive kernel.">QXMutex</a> </p>
<dl class="section user"><dt>Description</dt><dd>Unlock the QXK priority ceiling mutex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">me</td><td>pointer (see <a class="el" href="index.html#oop">Object Orientation</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function <b>can</b> be called from both basic threads (active objects) and extended threads.</dd>
<dd>
The mutex locks are allowed to nest, meaning that the same extended thread can lock the same mutex multiple times (&lt;= 225). However, each call to <a class="el" href="qxk__mutex_8c.html#a607a7442c8e54a46f404fcdf908cacf8" title="lock the QXK priority-ceiling mutex QXMutex">QXMutex_lock()</a> or a <em>successfull</em> call to <a class="el" href="qxk__mutex_8c.html#a32649853d09120e9d1256f5d115acaa8" title="try to lock the QXK priority-ceiling mutex QXMutex">QXMutex_tryLock()</a> must be ballanced by the matching call to <a class="el" href="qxk__mutex_8c.html#abc0780c17e77df45132fe218324bdf4f" title="unlock the QXK priority-ceiling mutex QXMutex">QXMutex_unlock()</a>.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><a class="code" href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a> l_rndMutex;  <span class="comment">/* mutex to protect the random number generator */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BSP_randomSeed(<a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> seed) {</div>
<div class="line">    <a class="code" href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f">QXMutex_init</a>(&amp;l_rndMutex, N_PHILO); <span class="comment">/* &lt;== initialize the mutex */</span></div>
<div class="line">    l_rnd = seed;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> BSP_random(<span class="keywordtype">void</span>) { <span class="comment">/* a very cheap pseudo-random-number generator */</span></div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a> rnd;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8">QXMutex_lock</a>(&amp;l_rndMutex); <span class="comment">/* &lt;== lock the shared random seed */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* &quot;Super-Duper&quot; Linear Congruential Generator (LCG) */</span></div>
<div class="line">    rnd = l_rnd * (3U*7U*11U*13U*23U);</div>
<div class="line">    l_rnd = rnd; <span class="comment">/* set for the next time */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f">QXMutex_unlock</a>(&amp;l_rndMutex); <span class="comment">/* &lt;== unlock the shared random seed */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> rnd;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>this function must:<ul>
<li>NOT be called from an ISR;</li>
<li>the calling thread must be valid;</li>
<li>the ceiling must not be used or<ul>
<li>the current thread must have priority equal to the mutex ceiling.</li>
</ul>
</li>
<li>the ceiling must be in range</li>
</ul>
</dd>
<dd>
also: the mutex must be already locked at least once.</dd>
<dd>
also: the mutex must be held by this thread.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qxk__mutex_8c_source.html#l00358">358</a> of file <a class="el" href="qxk__mutex_8c_source.html">qxk_mutex.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aqpc_8h_html"><div class="ttname"><a href="qpc_8h.html">qpc.h</a></div><div class="ttdoc">QP/C public interface including backwards-compatibility layer.</div></div>
<div class="ttc" id="aqassert_8h_html_a27042866331f49c9e9ff4f3ef459eaaf"><div class="ttname"><a href="qassert_8h.html#a27042866331f49c9e9ff4f3ef459eaaf">Q_DEFINE_THIS_FILE</a></div><div class="ttdeci">#define Q_DEFINE_THIS_FILE</div><div class="ttdoc">Define the file name (with __FILE__) for assertions in this file.</div><div class="ttdef"><b>Definition:</b> <a href="qassert_8h_source.html#l00104">qassert.h:104</a></div></div>
<div class="ttc" id="aqxthread_8h_html_struct_q_x_semaphore"><div class="ttname"><a href="qxthread_8h.html#struct_q_x_semaphore">QXSemaphore</a></div><div class="ttdoc">Counting Semaphore of the QXK preemptive kernel.</div><div class="ttdef"><b>Definition:</b> <a href="qxthread_8h_source.html#l00183">qxthread.h:183</a></div></div>
<div class="ttc" id="aqf_8h_html_a1c4fc5636c2bc2e9d47e958aac05b8e1"><div class="ttname"><a href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a></div><div class="ttdeci">void QF_poolInit(void *const poolSto, uint_fast32_t const poolSize, uint_fast16_t const evtSize)</div><div class="ttdoc">Event pool initialization for dynamic allocation of events.</div><div class="ttdef"><b>Definition:</b> <a href="qf__dyn_8c_source.html#l00113">qf_dyn.c:113</a></div></div>
<div class="ttc" id="aqxthread_8h_html_a8307d81827e59120494adddde980bf7c"><div class="ttname"><a href="qxthread_8h.html#a8307d81827e59120494adddde980bf7c">QXThread_ctor</a></div><div class="ttdeci">void QXThread_ctor(QXThread *const me, QXThreadHandler handler, uint_fast8_t tickRate)</div><div class="ttdoc">constructor of an extended-thread</div><div class="ttdef"><b>Definition:</b> <a href="qxk__xthr_8c_source.html#l00113">qxk_xthr.c:113</a></div></div>
<div class="ttc" id="aqxthread_8h_html_abace4abc24887d0adaadb26642133cfd"><div class="ttname"><a href="qxthread_8h.html#abace4abc24887d0adaadb26642133cfd">QXTHREAD_NO_TIMEOUT</a></div><div class="ttdeci">#define QXTHREAD_NO_TIMEOUT</div><div class="ttdoc">no-timeout special timeout value when blocking on queues or semaphores</div><div class="ttdef"><b>Definition:</b> <a href="qxthread_8h_source.html#l00160">qxthread.h:160</a></div></div>
<div class="ttc" id="aqxthread_8h_html_a25c3d21c629fb4d36aedc9e127ae3c75"><div class="ttname"><a href="qxthread_8h.html#a25c3d21c629fb4d36aedc9e127ae3c75">QXSemaphore_init</a></div><div class="ttdeci">void QXSemaphore_init(QXSemaphore *const me, uint_fast16_t count, uint_fast16_t max_count)</div><div class="ttdoc">initialize the counting semaphore</div><div class="ttdef"><b>Definition:</b> <a href="qxk__sema_8c_source.html#l00079">qxk_sema.c:79</a></div></div>
<div class="ttc" id="astruct_q_active_vtable_html"><div class="ttname"><a href="struct_q_active_vtable.html">QActiveVtable</a></div><div class="ttdoc">Virtual table for the QActive class.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00169">qf.h:169</a></div></div>
<div class="ttc" id="aqf_8h_html_aa52b4d3c43a262022392c6e11be06436"><div class="ttname"><a href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a></div><div class="ttdeci">#define Q_NEW_X(e_, evtT_, margin_, sig_)</div><div class="ttdoc">Allocate a dynamic event (non-asserting version).</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00787">qf.h:787</a></div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_aaa5d1cd013383c889537491c3cfd9aad"><div class="ttname"><a href="16bit_2stdint_8h.html#aaa5d1cd013383c889537491c3cfd9aad">uint64_t</a></div><div class="ttdeci">unsigned long long uint64_t</div><div class="ttdoc">exact-width 64-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00032">16bit/stdint.h:32</a></div></div>
<div class="ttc" id="aqf_8h_html_a779a1bc9482e2d489dc87751cd100fdb"><div class="ttname"><a href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a></div><div class="ttdeci">int_t QF_run(void)</div><div class="ttdoc">Transfers control to QF to run the application.</div><div class="ttdef"><b>Definition:</b> <a href="qk_8c_source.html#l00133">qk.c:133</a></div></div>
<div class="ttc" id="astruct_q_active_html_a3123ef03f5d66d866da12c736ac574b0"><div class="ttname"><a href="struct_q_active.html#a3123ef03f5d66d866da12c736ac574b0">QActive::QACTIVE_START</a></div><div class="ttdeci">#define QACTIVE_START(me_, prio_, qSto_, qLen_, stkSto_, stkLen_, par_)</div><div class="ttdoc">Polymorphically start an active object.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00216">qf.h:216</a></div></div>
<div class="ttc" id="aqassert_8h_html_ad58d2c6dc25f8f0f764eb69faa79eee2"><div class="ttname"><a href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a></div><div class="ttdeci">#define Q_DIM(array_)</div><div class="ttdoc">Helper macro to calculate static dimension of a 1-dim array_.</div><div class="ttdef"><b>Definition:</b> <a href="qassert_8h_source.html#l00337">qassert.h:337</a></div></div>
<div class="ttc" id="astruct_q_active_html"><div class="ttname"><a href="struct_q_active.html">QActive</a></div><div class="ttdoc">Active Object base class (based on QHsm implementation)</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00116">qf.h:116</a></div></div>
<div class="ttc" id="aqf_8h_html_a3a20b07a97300a74383cd863cbfd6bc6"><div class="ttname"><a href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">QF_psInit</a></div><div class="ttdeci">void QF_psInit(QSubscrList *const subscrSto, enum_t const maxSignal)</div><div class="ttdoc">Publish-subscribe initialization.</div><div class="ttdef"><b>Definition:</b> <a href="qf__ps_8c_source.html#l00087">qf_ps.c:87</a></div></div>
<div class="ttc" id="astruct_q_active_html_a766856b24aa5163b7ca90bc3432f1e3e"><div class="ttname"><a href="struct_q_active.html#a766856b24aa5163b7ca90bc3432f1e3e">QActive::QACTIVE_POST_X</a></div><div class="ttdeci">#define QACTIVE_POST_X(me_, e_, margin_, sender_)</div><div class="ttdoc">Polymorphically posts an event to an active object (FIFO) without delivery guarantee.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00291">qf.h:291</a></div></div>
<div class="ttc" id="aqf_8h_html_adac7eccb860d910c4e446d3143798bba"><div class="ttname"><a href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a></div><div class="ttdeci">void QF_init(void)</div><div class="ttdoc">QF initialization.</div><div class="ttdef"><b>Definition:</b> <a href="qk_8c_source.html#l00072">qk.c:72</a></div></div>
<div class="ttc" id="aqxthread_8h_html_a0a42fa24556ea0d0a203d28555b70108"><div class="ttname"><a href="qxthread_8h.html#a0a42fa24556ea0d0a203d28555b70108">QXSemaphore_signal</a></div><div class="ttdeci">bool QXSemaphore_signal(QXSemaphore *const me)</div><div class="ttdoc">signal (unblock) the semaphore</div><div class="ttdef"><b>Definition:</b> <a href="qxk__sema_8c_source.html#l00240">qxk_sema.c:240</a></div></div>
<div class="ttc" id="astruct_q_evt_html"><div class="ttname"><a href="struct_q_evt.html">QEvt</a></div><div class="ttdoc">Event class.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00151">qep.h:151</a></div></div>
<div class="ttc" id="astruct_q_x_thread_html"><div class="ttname"><a href="struct_q_x_thread.html">QXThread</a></div><div class="ttdoc">eXtended (blocking) thread of the QXK preemptive kernel</div><div class="ttdef"><b>Definition:</b> <a href="qxthread_8h_source.html#l00073">qxthread.h:73</a></div></div>
<div class="ttc" id="aqxthread_8h_html_af446f227f03a1a71b5e064271b5da64f"><div class="ttname"><a href="qxthread_8h.html#af446f227f03a1a71b5e064271b5da64f">QXMutex_init</a></div><div class="ttdeci">void QXMutex_init(QXMutex *const me, uint_fast8_t ceiling)</div><div class="ttdoc">initialize the QXK priority-ceiling mutex QXMutex</div><div class="ttdef"><b>Definition:</b> <a href="qxk__mutex_8c_source.html#l00087">qxk_mutex.c:87</a></div></div>
<div class="ttc" id="aqxthread_8h_html_struct_q_x_mutex"><div class="ttname"><a href="qxthread_8h.html#struct_q_x_mutex">QXMutex</a></div><div class="ttdoc">Blocking Mutex the QXK preemptive kernel.</div><div class="ttdef"><b>Definition:</b> <a href="qxthread_8h_source.html#l00245">qxthread.h:245</a></div></div>
<div class="ttc" id="aqxthread_8h_html_a3a257074a0f50871ab5e93fb1b761627"><div class="ttname"><a href="qxthread_8h.html#a3a257074a0f50871ab5e93fb1b761627">QXTHREAD_START</a></div><div class="ttdeci">#define QXTHREAD_START(me_, prio_, qSto_, qLen_, stkSto_, stkSize_, par_)</div><div class="ttdoc">Polymorphically start an extended thread.</div><div class="ttdef"><b>Definition:</b> <a href="qxthread_8h_source.html#l00103">qxthread.h:103</a></div></div>
<div class="ttc" id="aqxthread_8h_html_abc0780c17e77df45132fe218324bdf4f"><div class="ttname"><a href="qxthread_8h.html#abc0780c17e77df45132fe218324bdf4f">QXMutex_unlock</a></div><div class="ttdeci">void QXMutex_unlock(QXMutex *const me)</div><div class="ttdoc">unlock the QXK priority-ceiling mutex QXMutex</div><div class="ttdef"><b>Definition:</b> <a href="qxk__mutex_8c_source.html#l00358">qxk_mutex.c:358</a></div></div>
<div class="ttc" id="aqxthread_8h_html_a93c62839759971359392742618d58e70"><div class="ttname"><a href="qxthread_8h.html#a93c62839759971359392742618d58e70">QXSemaphore_wait</a></div><div class="ttdeci">bool QXSemaphore_wait(QXSemaphore *const me, uint_fast16_t const nTicks)</div><div class="ttdoc">wait (block) on the semaphore</div><div class="ttdef"><b>Definition:</b> <a href="qxk__sema_8c_source.html#l00114">qxk_sema.c:114</a></div></div>
<div class="ttc" id="aqxthread_8h_html_a607a7442c8e54a46f404fcdf908cacf8"><div class="ttname"><a href="qxthread_8h.html#a607a7442c8e54a46f404fcdf908cacf8">QXMutex_lock</a></div><div class="ttdeci">bool QXMutex_lock(QXMutex *const me, uint_fast16_t const nTicks)</div><div class="ttdoc">lock the QXK priority-ceiling mutex QXMutex</div><div class="ttdef"><b>Definition:</b> <a href="qxk__mutex_8c_source.html#l00134">qxk_mutex.c:134</a></div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_a33594304e786b158f3fb30289278f5af"><div class="ttname"><a href="16bit_2stdint_8h.html#a33594304e786b158f3fb30289278f5af">uint32_t</a></div><div class="ttdeci">unsigned long int uint32_t</div><div class="ttdoc">exact-width 32-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00031">16bit/stdint.h:31</a></div></div>
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="navelem"><a class="el" href="dir_9b55b230f41344f00f9f1f35be51edc6.html">include</a></li><li class="navelem"><a class="el" href="qxthread_8h.html">qxthread.h</a></li>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C 6.9.1</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C 6.9.1</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
