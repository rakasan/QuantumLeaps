<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: qf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <a id="logo" title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">
    <img src="img/logo_ql.png" alt="Quantum Leaps" style="vertical-align:top; border:none;">
  </a>
  <span id="projectname">QP/C</span>
  <span id="projectnumber">6.9.1</span>
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('qf_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qf.h File Reference<div class="ingroups"><a class="el" href="group__qf.html">QF</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>QF/C platform-independent public interface.
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="qpset_8h_source.html">qpset.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for qf.h:</div>
<div class="dyncontent">
<div class="center"><img src="qf_8h__incl.png" border="0" usemap="#aqf_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="qf_8h__dep__incl.png" border="0" usemap="#aqf_8hdep" alt=""/></div>
</div>
</div>
<p><a href="qf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_active.html">QActive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Active Object base class (based on <a class="el" href="struct_q_hsm.html" title="Hierarchical State Machine class.">QHsm</a> implementation)  <a href="struct_q_active.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_active_vtable.html">QActiveVtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual table for the <a class="el" href="struct_q_active.html" title="Active Object base class (based on QHsm implementation)">QActive</a> class.  <a href="struct_q_active_vtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_m_active.html">QMActive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_q_m_active.html" title="QMActive active object base class (based on QMsm implementation)">QMActive</a> active object base class (based on <a class="el" href="struct_q_msm.html" title="QM State Machine implementation strategy.">QMsm</a> implementation)  <a href="struct_q_m_active.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_time_evt.html">QTimeEvt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time Event class.  <a href="struct_q_time_evt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_ticker.html">QTicker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_q_ticker.html" title="QTicker Active Object class.">QTicker</a> Active Object class.  <a href="struct_q_ticker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afd57334f2a1664a168b0702a106e0782"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782">QF_PUBLISH</a>(e_,  sender_)&#160;&#160;&#160;        (<a class="el" href="qf__ps_8c.html#a1fb533f5e56964494448184a1991f8db">QF_publish_</a>((e_), (void const *)(sender_)))</td></tr>
<tr class="memdesc:afd57334f2a1664a168b0702a106e0782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the event publishing facility <a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>.  <a href="qf_8h.html#afd57334f2a1664a168b0702a106e0782">More...</a><br /></td></tr>
<tr class="separator:afd57334f2a1664a168b0702a106e0782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1970e16f4d010b5e5b2fd046aac41e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(tickRate_,  sender_)&#160;&#160;&#160;(<a class="el" href="qf__time_8c.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82">QF_tickX_</a>((tickRate_), (sender_)))</td></tr>
<tr class="memdesc:a1f1970e16f4d010b5e5b2fd046aac41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the system clock tick processing <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a>.  <a href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">More...</a><br /></td></tr>
<tr class="separator:a1f1970e16f4d010b5e5b2fd046aac41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1957439cb1ecff92be7b7401bf3159"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a>&#160;&#160;&#160;((<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)0xFFFFU)</td></tr>
<tr class="memdesc:a3c1957439cb1ecff92be7b7401bf3159"><td class="mdescLeft">&#160;</td><td class="mdescRight">special value of margin that causes asserting failure in case event allocation or event posting fails  <a href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">More...</a><br /></td></tr>
<tr class="separator:a3c1957439cb1ecff92be7b7401bf3159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095356f76aa32cb738325abfa55e96fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a095356f76aa32cb738325abfa55e96fc">QF_TICK</a>(sender_)&#160;&#160;&#160;<a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(0U, (sender_))</td></tr>
<tr class="memdesc:a095356f76aa32cb738325abfa55e96fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the system clock tick processing for rate 0.  <a href="qf_8h.html#a095356f76aa32cb738325abfa55e96fc">More...</a><br /></td></tr>
<tr class="separator:a095356f76aa32cb738325abfa55e96fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd823f3a9e8b3206a3460a108d5fa3e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a>(evtT_,  sig_)</td></tr>
<tr class="memdesc:abd823f3a9e8b3206a3460a108d5fa3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a dynamic event.  <a href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">More...</a><br /></td></tr>
<tr class="separator:abd823f3a9e8b3206a3460a108d5fa3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52b4d3c43a262022392c6e11be06436"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a>(e_,  evtT_,  margin_,  sig_)</td></tr>
<tr class="memdesc:aa52b4d3c43a262022392c6e11be06436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a dynamic event (non-asserting version).  <a href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">More...</a><br /></td></tr>
<tr class="separator:aa52b4d3c43a262022392c6e11be06436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0">Q_NEW_REF</a>(evtRef_,  evtT_)&#160;&#160;&#160;    ((evtRef_) = (evtT_ const *)<a class="el" href="qf__dyn_8c.html#a4c87ff6aaac16a7327a7437c4e72be24">QF_newRef_</a>(e, (evtRef_)))</td></tr>
<tr class="memdesc:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new reference of the current event <code>e</code>  <a href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0">More...</a><br /></td></tr>
<tr class="separator:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed009a86c52cf2b8d811389fabb5f23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23">Q_DELETE_REF</a>(evtRef_)</td></tr>
<tr class="memdesc:aaed009a86c52cf2b8d811389fabb5f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the event reference.  <a href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23">More...</a><br /></td></tr>
<tr class="separator:aaed009a86c52cf2b8d811389fabb5f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2">QF_CRIT_EXIT_NOP</a>()&#160;&#160;&#160;((void)0)</td></tr>
<tr class="memdesc:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-operation for exiting a critical section.  <a href="qf_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2">More...</a><br /></td></tr>
<tr class="separator:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abbb0c00f8a289282390cbd0173eee21c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#abbb0c00f8a289282390cbd0173eee21c">QEvtSize</a></td></tr>
<tr class="separator:abbb0c00f8a289282390cbd0173eee21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ae90801798660dc4c3aea59bfcbba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_q_active_vtable.html">QActiveVtable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a001ae90801798660dc4c3aea59bfcbba">QMActiveVtable</a></td></tr>
<tr class="memdesc:a001ae90801798660dc4c3aea59bfcbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Table for the <a class="el" href="struct_q_m_active.html" title="QMActive active object base class (based on QMsm implementation)">QMActive</a> class (inherited from <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>.  <a href="qf_8h.html#a001ae90801798660dc4c3aea59bfcbba">More...</a><br /></td></tr>
<tr class="separator:a001ae90801798660dc4c3aea59bfcbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3526b0c899ab9687db250ab58551e0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a></td></tr>
<tr class="separator:a1f3526b0c899ab9687db250ab58551e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1532f57deb6a85353b9c04bf054fec77"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="qpset_8h.html#struct_q_p_set">QPSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">QSubscrList</a></td></tr>
<tr class="memdesc:a1532f57deb6a85353b9c04bf054fec77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscriber-List structure.  <a href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">More...</a><br /></td></tr>
<tr class="separator:a1532f57deb6a85353b9c04bf054fec77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adac7eccb860d910c4e446d3143798bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a> (void)</td></tr>
<tr class="memdesc:adac7eccb860d910c4e446d3143798bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">QF initialization.  <a href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">More...</a><br /></td></tr>
<tr class="separator:adac7eccb860d910c4e446d3143798bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a20b07a97300a74383cd863cbfd6bc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">QF_psInit</a> (<a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">QSubscrList</a> *const subscrSto, <a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const maxSignal)</td></tr>
<tr class="memdesc:a3a20b07a97300a74383cd863cbfd6bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish-subscribe initialization.  <a href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">More...</a><br /></td></tr>
<tr class="separator:a3a20b07a97300a74383cd863cbfd6bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4fc5636c2bc2e9d47e958aac05b8e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a> (void *const poolSto, <a class="el" href="16bit_2stdint_8h.html#aeb3ae59c7d101507a3952f5de306ea95">uint_fast32_t</a> const poolSize, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const evtSize)</td></tr>
<tr class="memdesc:a1c4fc5636c2bc2e9d47e958aac05b8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event pool initialization for dynamic allocation of events.  <a href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">More...</a><br /></td></tr>
<tr class="separator:a1c4fc5636c2bc2e9d47e958aac05b8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c89d3e5e55aeeec9175ec95635476ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7c89d3e5e55aeeec9175ec95635476ce">QF_poolGetMaxBlockSize</a> (void)</td></tr>
<tr class="memdesc:a7c89d3e5e55aeeec9175ec95635476ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the block size of any registered event pools.  <a href="qf_8h.html#a7c89d3e5e55aeeec9175ec95635476ce">More...</a><br /></td></tr>
<tr class="separator:a7c89d3e5e55aeeec9175ec95635476ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779a1bc9482e2d489dc87751cd100fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a> (void)</td></tr>
<tr class="memdesc:a779a1bc9482e2d489dc87751cd100fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers control to QF to run the application.  <a href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">More...</a><br /></td></tr>
<tr class="separator:a779a1bc9482e2d489dc87751cd100fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9cb86740bf55c5ad55c1d44fd35921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop</a> (void)</td></tr>
<tr class="memdesc:adf9cb86740bf55c5ad55c1d44fd35921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function invoked by the application layer to stop the QF application and return control to the OS/Kernel.  <a href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921">More...</a><br /></td></tr>
<tr class="separator:adf9cb86740bf55c5ad55c1d44fd35921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189a6d2ece787717c81fbf51fd180732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup</a> (void)</td></tr>
<tr class="memdesc:a189a6d2ece787717c81fbf51fd180732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Startup QF callback.  <a href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732">More...</a><br /></td></tr>
<tr class="separator:a189a6d2ece787717c81fbf51fd180732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7e181f2e679e1fa77c1e915fbee3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup</a> (void)</td></tr>
<tr class="memdesc:a5d7e181f2e679e1fa77c1e915fbee3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup QF callback.  <a href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0">More...</a><br /></td></tr>
<tr class="separator:a5d7e181f2e679e1fa77c1e915fbee3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb533f5e56964494448184a1991f8db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db">QF_publish_</a> (<a class="el" href="struct_q_evt.html">QEvt</a> const *const e, void const *const sender)</td></tr>
<tr class="memdesc:a1fb533f5e56964494448184a1991f8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish event to the framework.  <a href="qf_8h.html#a1fb533f5e56964494448184a1991f8db">More...</a><br /></td></tr>
<tr class="separator:a1fb533f5e56964494448184a1991f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf676a0ed64ab7ed8a8151f1f2e7c82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82">QF_tickX_</a> (<a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const tickRate, void const *const sender)</td></tr>
<tr class="memdesc:a8cf676a0ed64ab7ed8a8151f1f2e7c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <a href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82">More...</a><br /></td></tr>
<tr class="separator:a8cf676a0ed64ab7ed8a8151f1f2e7c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691ef631f5557b516f13f32ca9eb1338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a691ef631f5557b516f13f32ca9eb1338">QF_noTimeEvtsActiveX</a> (<a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const tickRate)</td></tr>
<tr class="memdesc:a691ef631f5557b516f13f32ca9eb1338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 'true' if there are no armed time events at a given tick rate.  <a href="qf_8h.html#a691ef631f5557b516f13f32ca9eb1338">More...</a><br /></td></tr>
<tr class="separator:a691ef631f5557b516f13f32ca9eb1338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438fc360095cdafd2b4ba7f5d65bc9b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a438fc360095cdafd2b4ba7f5d65bc9b0">QF_add_</a> (<a class="el" href="struct_q_active.html">QActive</a> *const a)</td></tr>
<tr class="memdesc:a438fc360095cdafd2b4ba7f5d65bc9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an active object to be managed by the framework.  <a href="qf_8h.html#a438fc360095cdafd2b4ba7f5d65bc9b0">More...</a><br /></td></tr>
<tr class="separator:a438fc360095cdafd2b4ba7f5d65bc9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b0d9d2c9ad2546fea14975bc1a1328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a35b0d9d2c9ad2546fea14975bc1a1328">QF_remove_</a> (<a class="el" href="struct_q_active.html">QActive</a> *const a)</td></tr>
<tr class="memdesc:a35b0d9d2c9ad2546fea14975bc1a1328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the active object from the framework.  <a href="qf_8h.html#a35b0d9d2c9ad2546fea14975bc1a1328">More...</a><br /></td></tr>
<tr class="separator:a35b0d9d2c9ad2546fea14975bc1a1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52d81b1bd2cab6523fbe13cb5d79190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ae52d81b1bd2cab6523fbe13cb5d79190">QF_getPoolMin</a> (<a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const poolId)</td></tr>
<tr class="memdesc:ae52d81b1bd2cab6523fbe13cb5d79190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the minimum of free entries of the given event pool.  <a href="qf_8h.html#ae52d81b1bd2cab6523fbe13cb5d79190">More...</a><br /></td></tr>
<tr class="separator:ae52d81b1bd2cab6523fbe13cb5d79190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29692c0dcab731199b5beb5847484ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a29692c0dcab731199b5beb5847484ab7">QF_getQueueMin</a> (<a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const prio)</td></tr>
<tr class="memdesc:a29692c0dcab731199b5beb5847484ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the minimum of free entries of the given event queue.  <a href="qf_8h.html#a29692c0dcab731199b5beb5847484ab7">More...</a><br /></td></tr>
<tr class="separator:a29692c0dcab731199b5beb5847484ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c49ff8c7895ca20958de54583a4e9cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_evt.html">QEvt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">QF_newX_</a> (<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const evtSize, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const margin, <a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const sig)</td></tr>
<tr class="memdesc:a1c49ff8c7895ca20958de54583a4e9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal QF implementation of creating new dynamic event.  <a href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">More...</a><br /></td></tr>
<tr class="separator:a1c49ff8c7895ca20958de54583a4e9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c87ff6aaac16a7327a7437c4e72be24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_evt.html">QEvt</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a4c87ff6aaac16a7327a7437c4e72be24">QF_newRef_</a> (<a class="el" href="struct_q_evt.html">QEvt</a> const *const e, void const *const evtRef)</td></tr>
<tr class="memdesc:a4c87ff6aaac16a7327a7437c4e72be24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal QF implementation of creating new event reference.  <a href="qf_8h.html#a4c87ff6aaac16a7327a7437c4e72be24">More...</a><br /></td></tr>
<tr class="separator:a4c87ff6aaac16a7327a7437c4e72be24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb373ddc448c4198e4247b6c6ff3e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aebb373ddc448c4198e4247b6c6ff3e69">QF_deleteRef_</a> (void const *const evtRef)</td></tr>
<tr class="memdesc:aebb373ddc448c4198e4247b6c6ff3e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal QF implementation of deleting event reference.  <a href="qf_8h.html#aebb373ddc448c4198e4247b6c6ff3e69">More...</a><br /></td></tr>
<tr class="separator:aebb373ddc448c4198e4247b6c6ff3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa4e9d39b8af089405cb829e2cc5a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7aa4e9d39b8af089405cb829e2cc5a24">QF_gc</a> (<a class="el" href="struct_q_evt.html">QEvt</a> const *const e)</td></tr>
<tr class="memdesc:a7aa4e9d39b8af089405cb829e2cc5a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycle a dynamic event.  <a href="qf_8h.html#a7aa4e9d39b8af089405cb829e2cc5a24">More...</a><br /></td></tr>
<tr class="separator:a7aa4e9d39b8af089405cb829e2cc5a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5f5f3c33ce2706283cbe8179a9a2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1e5f5f3c33ce2706283cbe8179a9a2c5">QF_bzero</a> (void *const start, <a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> len)</td></tr>
<tr class="memdesc:a1e5f5f3c33ce2706283cbe8179a9a2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a specified region of memory to zero.  <a href="qf_8h.html#a1e5f5f3c33ce2706283cbe8179a9a2c5">More...</a><br /></td></tr>
<tr class="separator:a1e5f5f3c33ce2706283cbe8179a9a2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3558503dacda5fe520ce300fce4627a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a3558503dacda5fe520ce300fce4627a2">QTicker_ctor</a> (<a class="el" href="struct_q_ticker.html">QTicker</a> *const me, <a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> tickRate)</td></tr>
<tr class="memdesc:a3558503dacda5fe520ce300fce4627a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="struct_q_ticker.html" title="QTicker Active Object class.">QTicker</a> Active Object class.  <a href="qf_8h.html#a3558503dacda5fe520ce300fce4627a2">More...</a><br /></td></tr>
<tr class="separator:a3558503dacda5fe520ce300fce4627a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6ece34fc555ade0a6a10a259a6463401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a6ece34fc555ade0a6a10a259a6463401">QF_active_</a> [<a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a>+1U]</td></tr>
<tr class="memdesc:a6ece34fc555ade0a6a10a259a6463401"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of registered active objects  <a href="qf_8h.html#a6ece34fc555ade0a6a10a259a6463401">More...</a><br /></td></tr>
<tr class="separator:a6ece34fc555ade0a6a10a259a6463401"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>QF/C platform-independent public interface. </p>

<p class="definition">Definition in file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afd57334f2a1664a168b0702a106e0782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd57334f2a1664a168b0702a106e0782">&#9670;&nbsp;</a></span>QF_PUBLISH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_PUBLISH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;        (<a class="el" href="qf__ps_8c.html#a1fb533f5e56964494448184a1991f8db">QF_publish_</a>((e_), (void const *)(sender_)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the event publishing facility <a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>. </p>
<dl class="section user"><dt>Description</dt><dd>This macro is the recommended way of publishing events, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the posted event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object. This argument is actually only used when QS software tracing is enabled (macro <a class="el" href="macros_8h.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined). When QS software tracing is disabled, the macro calls <a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a> without the <code>sender_</code> parameter, so the overhead of passing this extra argument is entirely avoided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the pointer to the sender object is not necessarily a pointer to an active object. In fact, if <a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782" title="Invoke the event publishing facility QF_publish_().">QF_PUBLISH()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the publisher of the event.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a1fb533f5e56964494448184a1991f8db" title="Publish event to the framework.">QF_publish_()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00632">632</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a1f1970e16f4d010b5e5b2fd046aac41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1970e16f4d010b5e5b2fd046aac41e">&#9670;&nbsp;</a></span>QF_TICK_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_TICK_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tickRate_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="qf__time_8c.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82">QF_tickX_</a>((tickRate_), (sender_)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the system clock tick processing <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a>. </p>
<dl class="section user"><dt>Description</dt><dd>This macro is the recommended way of invoking clock tick processing, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate_</td><td>clock tick rate to be serviced through this call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object. This argument is actually only used when QS software tracing is enabled (macro <a class="el" href="macros_8h.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When QS software tracing is disabled, the macro calls <a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a> without the <code>sender</code> parameter, so the overhead of passing this extra argument is entirely avoided.</dd>
<dd>
The pointer to the sender object is not necessarily a pointer to an active object. In fact, when <a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e" title="Invoke the system clock tick processing QF_tickX_().">QF_TICK_X()</a> is called from an interrupt, you would create a unique object just to unambiguously identify the ISR as the sender of the time events.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example shows how to invoke <a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e" title="Invoke the system clock tick processing QF_tickX_().">QF_TICK_X()</a> for different system tick rates: <div class="fragment"><div class="line"><span class="comment">/* case 1: Interrupt Controller available,</span></div>
<div class="line"><span class="comment">* &quot;unconditional interrupt unlocking&quot; critical section policy</span></div>
<div class="line"><span class="comment">* (nesting of critical sections _not_ allowed)</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">interrupt <span class="keywordtype">void</span> ISR_timer() { <span class="comment">/* entered with interrupts disabled in hardware */</span></div>
<div class="line">    <a class="code" href="qk_2qf__port_8h.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a>();  <span class="comment">/* enable interrupts */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(0U, &amp;l_ISR_timer); <span class="comment">/*&lt;-- QF tick processing for rate 0 */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qk_2qf__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a>(); <span class="comment">/* disable interrupts again */</span></div>
<div class="line">    <span class="comment">/* send the EOI instruction to the Interrupt Controller */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* case 2: Interrupt Controller not used,</span></div>
<div class="line"><span class="comment">* &quot;saving and restoring interrupt status&quot; critical section policy</span></div>
<div class="line"><span class="comment">* (nesting of critical sections allowed)</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">interrupt <span class="keywordtype">void</span> ISR_timer() {</div>
<div class="line">    <a class="code" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(1U, &amp;l_ISR_timer); <span class="comment">/*&lt;-- QF tick processing for rate 1 */</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00675">675</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a3c1957439cb1ecff92be7b7401bf3159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1957439cb1ecff92be7b7401bf3159">&#9670;&nbsp;</a></span>QF_NO_MARGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_NO_MARGIN&#160;&#160;&#160;((<a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)0xFFFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special value of margin that causes asserting failure in case event allocation or event posting fails </p>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00687">687</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a095356f76aa32cb738325abfa55e96fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095356f76aa32cb738325abfa55e96fc">&#9670;&nbsp;</a></span>QF_TICK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_TICK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a>(0U, (sender_))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the system clock tick processing for rate 0. </p>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00690">690</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="abd823f3a9e8b3206a3460a108d5fa3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd823f3a9e8b3206a3460a108d5fa3e3">&#9670;&nbsp;</a></span>Q_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sig_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ((evtT_ *)<a class="code" href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">QF_newX_</a>((<a class="code" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)<span class="keyword">sizeof</span>(evtT_), \</div>
<div class="line">                           <a class="code" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a>, (sig_)))</div>
</div><!-- fragment -->
<p>Allocate a dynamic event. </p>
<dl class="section user"><dt>Description</dt><dd>The macro calls the internal QF function <a class="el" href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd" title="Internal QF implementation of creating new dynamic event.">QF_newX_()</a> with margin == <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a>, which causes an assertion when the event cannot be successfully allocated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtT_</td><td>event type (class name) of the event to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig_</td><td>signal to assign to the newly allocated event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid event pointer cast to the type <code>evtT_</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If Q_EVT_CTOR is defined, the <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a> macro becomes variadic and takes all the arguments needed by the constructor of the event class being allocated. The constructor is then called by means of the placement-new operator.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates dynamic allocation of an event: <div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_q_active.html">QActive</a> *AO_Table;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a> Philoso_hungry(Philo * <span class="keyword">const</span> me, <a class="code" href="struct_q_evt.html">QEvt</a> <span class="keyword">const</span> * <span class="keyword">const</span> e) {</div>
<div class="line">    <a class="code" href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a> status;</div>
<div class="line">    <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_evt.html#a20b1ceebb91aea39fcbc633aeae6cd3f">sig</a>) {</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {</div>
<div class="line">            TableEvt *pe = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a>(TableEvt, HUNGRY_SIG); <span class="comment">/* dynamic alloc */</span></div>
<div class="line">            pe-&gt;philNum = me-&gt;num;</div>
<div class="line">            <a class="code" href="struct_q_active.html#ab7c56990d949c8708e3fe2b737f2e65c">QACTIVE_POST</a>(AO_Table, &amp;pe-&gt;super, me); <span class="comment">/* direct posting */</span></div>
<div class="line">            status = <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a>();</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        . . .</div>
<div class="line">        <span class="keywordflow">default</span>: {</div>
<div class="line">            status = <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc">Q_SUPER</a>(&amp;<a class="code" href="struct_q_hsm.html#ac8ae4728dfab5ce26a907fc624f6e104">QHsm_top</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00756">756</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="aa52b4d3c43a262022392c6e11be06436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52b4d3c43a262022392c6e11be06436">&#9670;&nbsp;</a></span>Q_NEW_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">margin_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sig_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ((e_) = \</div>
<div class="line">        (evtT_ *)<a class="code" href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">QF_newX_</a>((<a class="code" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>)<span class="keyword">sizeof</span>(evtT_), (margin_), (sig_)))</div>
</div><!-- fragment -->
<p>Allocate a dynamic event (non-asserting version). </p>
<dl class="section user"><dt>Description</dt><dd>This macro allocates a new event and sets the pointer <code>e_</code>, while leaving at least <code>margin_</code> of events still available in the pool</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e_</td><td>pointer to the newly allocated event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtT_</td><td>event type (class name) of the event to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin_</td><td>number of events that must remain available in the given pool after this allocation. The special value <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> causes asserting failure in case event allocation or event posting fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig_</td><td>signal to assign to the newly allocated event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event pointer cast to the type <code>evtT_</code> or NULL if the event cannot be allocated with the specified <code>margin</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If Q_EVT_CTOR is defined, the <a class="el" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436" title="Allocate a dynamic event (non-asserting version).">Q_NEW_X()</a> macro becomes variadic and takes all the arguments needed by the constructor of the event class being allocated. The constructor is then called and all the extra arguments are passed to it.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example illustrates dynamic allocation of an event: <div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="struct_q_active.html">QActive</a> *AO_Table;</div>
<div class="line"> </div>
<div class="line">    . . .</div>
<div class="line">    <span class="comment">/* typically inside a state machine action */</span></div>
<div class="line">    TableEvt *pe;</div>
<div class="line">    <a class="code" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a>(pe, TableEvt, 5U, HUNGRY_SIG); <span class="comment">/* dynamic alloc, margin==5 */</span></div>
<div class="line">    <span class="keywordflow">if</span> (pe != (TableEvt *)0) {</div>
<div class="line">        pe-&gt;philNum = me-&gt;num;</div>
<div class="line">        <a class="code" href="struct_q_active.html#a766856b24aa5163b7ca90bc3432f1e3e">QACTIVE_POST_X</a>(AO_Table, &amp;pe-&gt;super, 3U, me); <span class="comment">/* margin==3 */</span></div>
<div class="line">    }</div>
<div class="line">    . . .</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00787">787</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a10162978b156ab5d2fd2e3a7aa744ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10162978b156ab5d2fd2e3a7aa744ac0">&#9670;&nbsp;</a></span>Q_NEW_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtRef_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ((evtRef_) = (evtT_ const *)<a class="el" href="qf__dyn_8c.html#a4c87ff6aaac16a7327a7437c4e72be24">QF_newRef_</a>(e, (evtRef_)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new reference of the current event <code>e</code> </p>
<dl class="section user"><dt>Description</dt><dd>The current event processed by an active object is available only for the duration of the run-to-completion (RTC) step. After that step, the current event is no longer available and the framework might recycle (garbage-collect) the event. The macro <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> explicitly creates a new reference to the current event that can be stored and used beyond the current RTC step, until the reference is explicitly recycled by means of the macro <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">evtRef_</td><td>event reference to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtT_</td><td>event type (class name) of the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>The example <b>defer</b> in the directory <code>examples/win32/defer</code> illustrates the use of <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00812">812</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="aaed009a86c52cf2b8d811389fabb5f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed009a86c52cf2b8d811389fabb5f23">&#9670;&nbsp;</a></span>Q_DELETE_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_DELETE_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtRef_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">    QF_deleteRef_((evtRef_));      \</div>
<div class="line">    (evtRef_) = (<span class="keywordtype">void</span> *)0;         \</div>
<div class="line">} <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Delete the event reference. </p>
<dl class="section user"><dt>Description</dt><dd>Every event reference created with the macro <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> needs to be eventually deleted by means of the macro <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a> to avoid leaking the event.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">evtRef_</td><td>event reference to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>The example <b>defer</b> in the directory <code>examples/win32/defer</code> illustrates the use of <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00830">830</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="adc8820f52d450bcfb7d1f830e6c8a8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8820f52d450bcfb7d1f830e6c8a8c2">&#9670;&nbsp;</a></span>QF_CRIT_EXIT_NOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_CRIT_EXIT_NOP</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;((void)0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No-operation for exiting a critical section. </p>
<dl class="section user"><dt>Description</dt><dd>In some QF ports the critical section exit takes effect only on the next machine instruction. If this next instruction is another entry to a critical section, the critical section won't be really exited, but rather the two adjacent critical sections would be merged. The <a class="el" href="qf_8h.html#adc8820f52d450bcfb7d1f830e6c8a8c2" title="No-operation for exiting a critical section.">QF_CRIT_EXIT_NOP()</a> macro contains minimal code required to prevent such merging of critical sections in QF ports, in which it can occur. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00853">853</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abbb0c00f8a289282390cbd0173eee21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb0c00f8a289282390cbd0173eee21c">&#9670;&nbsp;</a></span>QEvtSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <a class="el" href="qf_8h.html#abbb0c00f8a289282390cbd0173eee21c">QEvtSize</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00053">53</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a001ae90801798660dc4c3aea59bfcbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ae90801798660dc4c3aea59bfcbba">&#9670;&nbsp;</a></span>QMActiveVtable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_q_active_vtable.html">QActiveVtable</a> <a class="el" href="qf_8h.html#a001ae90801798660dc4c3aea59bfcbba">QMActiveVtable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual Table for the <a class="el" href="struct_q_m_active.html" title="QMActive active object base class (based on QMsm implementation)">QMActive</a> class (inherited from <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_q_m_active.html" title="QMActive active object base class (based on QMsm implementation)">QMActive</a> inherits <a class="el" href="struct_q_active.html" title="Active Object base class (based on QHsm implementation)">QActive</a> exactly, without adding any new virtual functions and therefore, <a class="el" href="qf_8h.html#a001ae90801798660dc4c3aea59bfcbba" title="Virtual Table for the QMActive class (inherited from QActiveVtable.">QMActiveVtable</a> is typedef'ed as <a class="el" href="struct_q_active_vtable.html" title="Virtual table for the QActive class.">QActiveVtable</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00410">410</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a1f3526b0c899ab9687db250ab58551e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3526b0c899ab9687db250ab58551e0">&#9670;&nbsp;</a></span>QTimeEvtCtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> <a class="el" href="qf_8h.html#a1f3526b0c899ab9687db250ab58551e0">QTimeEvtCtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00421">421</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a1532f57deb6a85353b9c04bf054fec77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1532f57deb6a85353b9c04bf054fec77">&#9670;&nbsp;</a></span>QSubscrList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="qpset_8h.html#struct_q_p_set">QPSet</a> <a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">QSubscrList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscriber-List structure. </p>
<dl class="section user"><dt>Description</dt><dd>This data type represents a set of active objects that subscribe to a given signal. The set is represented as a priority-set, where each bit corresponds to the unique priority of an active object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77" title="Subscriber-List structure.">QSubscrList</a> for the description of the data members </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l00555">555</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adac7eccb860d910c4e446d3143798bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac7eccb860d910c4e446d3143798bba">&#9670;&nbsp;</a></span>QF_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QF initialization. </p>
<dl class="section user"><dt>Description</dt><dd>Initializes QF and must be called exactly once before any other QF function. Typically, <a class="el" href="qk_8c.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> is called from main() even before initializing the Board Support Package (BSP).</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="qk_8c.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> clears the internal QF variables, so that the framework can start correctly even if the startup code fails to clear the uninitialized data (as is required by the C Standard). </dd></dl>

<p class="definition">Definition at line <a class="el" href="qk_8c_source.html#l00072">72</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
<a id="a3a20b07a97300a74383cd863cbfd6bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a20b07a97300a74383cd863cbfd6bc6">&#9670;&nbsp;</a></span>QF_psInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_psInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77">QSubscrList</a> *const&#160;</td>
          <td class="paramname"><em>subscrSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const&#160;</td>
          <td class="paramname"><em>maxSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish-subscribe initialization. </p>
<dl class="section user"><dt>Description</dt><dd>This function initializes the publish-subscribe facilities of QF and must be called exactly once before any subscriptions/publications occur in the application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscrSto</td><td>pointer to the array of subscriber lists </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSignal</td><td>the dimension of the subscriber array and at the same time the maximum signal that can be published or subscribed.</td></tr>
  </table>
  </dd>
</dl>
<p>The array of subscriber-lists is indexed by signals and provides a mapping between the signals and subscriber-lists. The subscriber-lists are bitmasks of type <a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77" title="Subscriber-List structure.">QSubscrList</a>, each bit in the bit mask corresponding to the unique priority of an active object. The size of the <a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77" title="Subscriber-List structure.">QSubscrList</a> bit mask depends on the value of the <a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>The publish-subscribe facilities are optional, meaning that you might choose not to use publish-subscribe. In that case calling <a class="el" href="qf__ps_8c.html#a3a20b07a97300a74383cd863cbfd6bc6" title="Publish-subscribe initialization.">QF_psInit()</a> and using up memory for the subscriber-lists is unnecessary.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a1532f57deb6a85353b9c04bf054fec77" title="Subscriber-List structure.">QSubscrList</a></dd></dl>
<dl class="section user"><dt>Usage</dt><dd>The following example shows the typical initialization sequence of QF: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="qpc_8h.html">qpc.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="qassert_8h.html#a27042866331f49c9e9ff4f3ef459eaaf">Q_DEFINE_THIS_FILE</a></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="struct_q_evt.html">QEvt</a> <span class="keyword">const</span> *l_tableQueueSto[N_PHILO];</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="struct_q_evt.html">QEvt</a> <span class="keyword">const</span> *l_philoQueueSto[N_PHILO][N_PHILO];</div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="qpset_8h.html#struct_q_p_set">QSubscrList</a> l_subscrSto[MAX_PUB_SIG];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* storage for event pools... */</span></div>
<div class="line">    <span class="keyword">static</span> <a class="code" href="qmpool_8h.html#ab0fe475154021674f904c52e61e78841">QF_MPOOL_EL</a>(TableEvt) l_smlPoolSto[2*N_PHILO]; <span class="comment">/* small pool */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> n;</div>
<div class="line"> </div>
<div class="line">    Philo_ctor(); <span class="comment">/* instantiate all Philosopher active objects */</span></div>
<div class="line">    Table_ctor(); <span class="comment">/* instantiate the Table active object */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a>();  <span class="comment">/* initialize the framework and the underlying RT kernel */</span></div>
<div class="line">    BSP_init(); <span class="comment">/* initialize the BSP */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* send object dictionaries for event pools... */</span></div>
<div class="line">    <a class="code" href="qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(l_smlPoolSto);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* init publish-subscribe... */</span></div>
<div class="line">    <a class="code" href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">QF_psInit</a>(l_subscrSto, <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_subscrSto));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* initialize event pools... */</span></div>
<div class="line">    <a class="code" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a>(l_smlPoolSto, <span class="keyword">sizeof</span>(l_smlPoolSto), <span class="keyword">sizeof</span>(l_smlPoolSto[0]));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* start the active objects... */</span></div>
<div class="line">    <span class="keywordflow">for</span> (n = 0; n &lt; N_PHILO; ++n) {</div>
<div class="line">        <a class="code" href="struct_q_active.html#a3123ef03f5d66d866da12c736ac574b0">QACTIVE_START</a>(AO_Philo[n], (<a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>)(n + 1),</div>
<div class="line">                      l_philoQueueSto[n], <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]),</div>
<div class="line">                      (<span class="keywordtype">void</span> *)0, 0U, (<a class="code" href="struct_q_evt.html">QEvt</a> *)0);</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="struct_q_active.html#a3123ef03f5d66d866da12c736ac574b0">QACTIVE_START</a>(AO_Table, (<a class="code" href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>)(N_PHILO + 1),</div>
<div class="line">                  l_tableQueueSto, <a class="code" href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_tableQueueSto),</div>
<div class="line">                  (<span class="keywordtype">void</span> *)0, 0U, (<a class="code" href="struct_q_evt.html">QEvt</a> *)0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a>(); <span class="comment">/* run the QF application, QF_run() does not return  */</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__ps_8c_source.html#l00087">87</a> of file <a class="el" href="qf__ps_8c_source.html">qf_ps.c</a>.</p>

</div>
</div>
<a id="a1c4fc5636c2bc2e9d47e958aac05b8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4fc5636c2bc2e9d47e958aac05b8e1">&#9670;&nbsp;</a></span>QF_poolInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_poolInit </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>poolSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#aeb3ae59c7d101507a3952f5de306ea95">uint_fast32_t</a> const&#160;</td>
          <td class="paramname"><em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>evtSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event pool initialization for dynamic allocation of events. </p>
<dl class="section user"><dt>Description</dt><dd>This function initializes one event pool at a time and must be called exactly once for each event pool before the pool can be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poolSto</td><td>pointer to the storage for the event pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poolSize</td><td>size of the storage for the pool in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtSize</td><td>the block-size of the pool in bytes, which determines the maximum size of events that can be allocated from the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>You might initialize many event pools by making many consecutive calls to the <a class="el" href="qf__dyn_8c.html#a1c4fc5636c2bc2e9d47e958aac05b8e1" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> function. However, for the simplicity of the internal implementation, you must initialize event pools in the <b>ascending order</b> of the event size.</dd></dl>
<p>Many RTOSes provide fixed block-size heaps, a.k.a. memory pools that can be adapted for QF event pools. In case such support is missing, QF provides a native QF event pool implementation. The macro <a class="el" href="qxk_8h.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a> determines the type of event pool used by a particular QF port. See structure <a class="el" href="qmpool_8h.html#struct_q_m_pool" title="Native QF Memory Pool.">QMPool</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The actual number of events available in the pool might be actually less than (<code>poolSize</code> / <code>evtSize</code>) due to the internal alignment of the blocks that the pool might perform. You can always check the capacity of the pool by calling <a class="el" href="qf_8h.html#ae52d81b1bd2cab6523fbe13cb5d79190" title="Obtain the minimum of free entries of the given event pool.">QF_getPoolMin()</a>.</dd>
<dd>
The dynamic allocation of events is optional, meaning that you might choose not to use dynamic events. In that case calling <a class="el" href="qf__dyn_8c.html#a1c4fc5636c2bc2e9d47e958aac05b8e1" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> and using up memory for the memory blocks is unnecessary.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>QF initialization example for <a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>cannot exceed the number of available memory pools</dd>
<dd>
please initialize event pools in ascending order of evtSize:</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00113">113</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a7c89d3e5e55aeeec9175ec95635476ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c89d3e5e55aeeec9175ec95635476ce">&#9670;&nbsp;</a></span>QF_poolGetMaxBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> QF_poolGetMaxBlockSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the block size of any registered event pools. </p>
<dl class="section user"><dt>Description</dt><dd>Obtain the block size of any registered event pools </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00357">357</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a779a1bc9482e2d489dc87751cd100fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779a1bc9482e2d489dc87751cd100fdb">&#9670;&nbsp;</a></span>QF_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a> QF_run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfers control to QF to run the application. </p>
<dl class="section user"><dt>Description</dt><dd><a class="el" href="qxk_8c.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a> is typically called from your startup code after you initialize the QF and start at least one active object with <a class="el" href="struct_q_active.html#a3123ef03f5d66d866da12c736ac574b0" title="Polymorphically start an active object.">QACTIVE_START()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>In QK, the <a class="el" href="qxk_8c.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a> does not return.</dd></dl>
<dl class="section user"><dt>Description</dt><dd><a class="el" href="qxk_8c.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a> is typically called from main() after you initialize the QF and start at least one active object with <a class="el" href="struct_q_active.html#a3123ef03f5d66d866da12c736ac574b0" title="Polymorphically start an active object.">QACTIVE_START()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>In QV, the <a class="el" href="qxk_8c.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a> function does not return.</dd></dl>
<dl class="section user"><dt>Description</dt><dd><a class="el" href="qxk_8c.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a> is typically called from main() after you initialize the QF and start at least one active object with <a class="el" href="struct_q_active.html#a3123ef03f5d66d866da12c736ac574b0" title="Polymorphically start an active object.">QACTIVE_START()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>In QXK, the <a class="el" href="qxk_8c.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a> function does not return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qk_8c_source.html#l00133">133</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
<a id="adf9cb86740bf55c5ad55c1d44fd35921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9cb86740bf55c5ad55c1d44fd35921">&#9670;&nbsp;</a></span>QF_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function invoked by the application layer to stop the QF application and return control to the OS/Kernel. </p>
<dl class="section user"><dt>Description</dt><dd>This function stops the QF application. After calling this function, QF attempts to gracefully stop the application. This graceful shutdown might take some time to complete. The typical use of this function is for terminating the QF application to return back to the operating system or for handling fatal errors that require shutting down (and possibly re-setting) the system.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>After calling <a class="el" href="qk_8c.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> the application must terminate and cannot continue. In particular, <a class="el" href="qk_8c.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> is <b>not</b> intended to be followed by a call to <a class="el" href="qk_8c.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> to "resurrect" the application.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qk_8c_source.html#l00107">107</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
<a id="a189a6d2ece787717c81fbf51fd180732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189a6d2ece787717c81fbf51fd180732">&#9670;&nbsp;</a></span>QF_onStartup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onStartup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Startup QF callback. </p>
<dl class="section user"><dt>Description</dt><dd>The timeline for calling <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732" title="Startup QF callback.">QF_onStartup()</a> depends on the particular QF port. In most cases, <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732" title="Startup QF callback.">QF_onStartup()</a> is called from <a class="el" href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb" title="Transfers control to QF to run the application.">QF_run()</a>, right before starting any multitasking kernel or the background loop. </dd></dl>

</div>
</div>
<a id="a5d7e181f2e679e1fa77c1e915fbee3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7e181f2e679e1fa77c1e915fbee3e0">&#9670;&nbsp;</a></span>QF_onCleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onCleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup QF callback. </p>
<dl class="section user"><dt>Description</dt><dd><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> is called in some QF ports before QF returns to the underlying operating system or RTOS.</dd></dl>
<p>This function is strongly platform-specific and is not implemented in the QF, but either in the QF port or in the Board Support Package (BSP) for the given application. Some QF ports might not require implementing <a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> at all, because many embedded applications don't have anything to exit to.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> </dd></dl>

</div>
</div>
<a id="a1fb533f5e56964494448184a1991f8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb533f5e56964494448184a1991f8db">&#9670;&nbsp;</a></span>QF_publish_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_publish_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish event to the framework. </p>
<dl class="section user"><dt>Description</dt><dd>This function posts (using the FIFO policy) the event <em>e</em> to <b>all</b> active objects that have subscribed to the signal <em>e-&gt;sig</em>, which is called <em>multicasting</em>. The multicasting performed in this function is very efficient based on reference-counting inside the published event ("zero-copy" event multicasting). This function is designed to be callable from any part of the system, including ISRs, device drivers, and active objects.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To avoid any unexpected re-ordering of events posted into AO queues, the event multicasting is performed with scheduler <b>locked</b>. However, the scheduler is locked only up to the priority level of the highest- priority subscriber, so any AOs of even higher priority, which did not subscribe to this event are <em>not</em> affected.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>this function should be called only via the macro <a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782" title="Invoke the event publishing facility QF_publish_().">QF_PUBLISH()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the published signal must be within the configured range</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__ps_8c_source.html#l00121">121</a> of file <a class="el" href="qf__ps_8c_source.html">qf_ps.c</a>.</p>

</div>
</div>
<a id="a8cf676a0ed64ab7ed8a8151f1f2e7c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf676a0ed64ab7ed8a8151f1f2e7c82">&#9670;&nbsp;</a></span>QF_tickX_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_tickX_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>tickRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes all armed time events at every clock tick. </p>
<dl class="section user"><dt>Description</dt><dd>This function must be called periodically from a time-tick ISR or from a task so that QF can manage the timeout events assigned to the given system clock tick rate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate</td><td>system clock tick rate serviced in this call [1..15]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender</td><td>pointer to a sender object (used only for QS tracing)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function should be called only via the macro <a class="el" href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e" title="Invoke the system clock tick processing QF_tickX_().">QF_TICK_X()</a></dd>
<dd>
the calls to <a class="el" href="qf__time_8c.html#a8cf676a0ed64ab7ed8a8151f1f2e7c82" title="Processes all armed time events at every clock tick.">QF_tickX_()</a> with different <code>tickRate</code> parameter can preempt each other. For example, higher clock tick rates might be serviced from interrupts while others from tasks (active objects).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_q_time_evt.html" title="Time Event class.">QTimeEvt</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00078">78</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a691ef631f5557b516f13f32ca9eb1338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691ef631f5557b516f13f32ca9eb1338">&#9670;&nbsp;</a></span>QF_noTimeEvtsActiveX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> QF_noTimeEvtsActiveX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>tickRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 'true' if there are no armed time events at a given tick rate. </p>
<dl class="section user"><dt>Description</dt><dd>Find out if any time events are armed at the given clock tick rate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate</td><td>system clock tick rate to find out about.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if no time events are armed at the given tick rate and 'false' otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called in critical section. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__time_8c_source.html#l00205">205</a> of file <a class="el" href="qf__time_8c_source.html">qf_time.c</a>.</p>

</div>
</div>
<a id="a438fc360095cdafd2b4ba7f5d65bc9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438fc360095cdafd2b4ba7f5d65bc9b0">&#9670;&nbsp;</a></span>QF_add_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_add_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *const&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an active object to be managed by the framework. </p>
<dl class="section user"><dt>Description</dt><dd>This function adds a given active object to the active objects managed by the QF framework. It should not be called by the application directly, only by the QP ports.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the active object to add to the framework.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The priority of the active object <code>a</code> should be set before calling this function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__act_8c.html#a35b0d9d2c9ad2546fea14975bc1a1328" title="Remove the active object from the framework.">QF_remove_()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the priority of the active object must not be zero and cannot exceed the maximum <a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>. Also, the priority of the active object must not be already in use. QF requires each active object to have a <b>unique</b> priority.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__act_8c_source.html#l00070">70</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

</div>
</div>
<a id="a35b0d9d2c9ad2546fea14975bc1a1328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b0d9d2c9ad2546fea14975bc1a1328">&#9670;&nbsp;</a></span>QF_remove_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_remove_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *const&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the active object from the framework. </p>
<dl class="section user"><dt>Description</dt><dd>This function removes a given active object from the active objects managed by the QF framework. It should not be called by the application directly, only by the QP ports.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>pointer to the active object to remove from the framework.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The active object that is removed from the framework can no longer participate in the publish-subscribe event exchange.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf__act_8c.html#a438fc360095cdafd2b4ba7f5d65bc9b0" title="Register an active object to be managed by the framework.">QF_add_()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the priority of the active object must not be zero and cannot exceed the maximum <a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>. Also, the priority of the active object must be already registered with the framework.</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__act_8c_source.html#l00103">103</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

</div>
</div>
<a id="ae52d81b1bd2cab6523fbe13cb5d79190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52d81b1bd2cab6523fbe13cb5d79190">&#9670;&nbsp;</a></span>QF_getPoolMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> QF_getPoolMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the minimum of free entries of the given event pool. </p>
<dl class="section user"><dt>Description</dt><dd>This function obtains the minimum number of free blocks in the given event pool since this pool has been initialized by a call to <a class="el" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poolId</td><td>event pool ID in the range 1..QF_maxPool_, where QF_maxPool_ is the number of event pools initialized with the function <a class="el" href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of unused blocks in the given event pool. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the poolId must be in range</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__mem_8c_source.html#l00294">294</a> of file <a class="el" href="qf__mem_8c_source.html">qf_mem.c</a>.</p>

</div>
</div>
<a id="a29692c0dcab731199b5beb5847484ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29692c0dcab731199b5beb5847484ab7">&#9670;&nbsp;</a></span>QF_getQueueMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> QF_getQueueMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a> const&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the minimum of free entries of the given event queue. </p>
<dl class="section user"><dt>Description</dt><dd>Queries the minimum of free ever present in the given event queue of an active object with priority <code>prio</code>, since the active object was started.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is available only when the native QF event queue implementation is used. Requesting the queue minimum of an unused priority level raises an assertion in the QF. (A priority level becomes used in QF after the call to the <a class="el" href="qf_8h.html#a438fc360095cdafd2b4ba7f5d65bc9b0" title="Register an active object to be managed by the framework.">QF_add_()</a> function.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>Priority of the active object, whose queue is queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum of free ever present in the given event queue of an active object with priority <code>prio</code>, since the active object was started. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__actq_8c_source.html#l00392">392</a> of file <a class="el" href="qf__actq_8c_source.html">qf_actq.c</a>.</p>

</div>
</div>
<a id="a1c49ff8c7895ca20958de54583a4e9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c49ff8c7895ca20958de54583a4e9cd">&#9670;&nbsp;</a></span>QF_newX_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_evt.html">QEvt</a>* QF_newX_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>evtSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a> const&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal QF implementation of creating new dynamic event. </p>
<dl class="section user"><dt>Description</dt><dd>Allocates an event dynamically from one of the QF event pools.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtSize</td><td>the size (in bytes) of the event to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin</td><td>the number of un-allocated events still available in a given event pool after the allocation completes. The special value <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> means that this function will assert if allocation fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>the signal to be assigned to the allocated event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly allocated event. This pointer can be NULL only if margin != <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> and the event cannot be allocated with the specified margin still available in the given pool.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The internal QF function <a class="el" href="qf__dyn_8c.html#a1c49ff8c7895ca20958de54583a4e9cd" title="Internal QF implementation of creating new dynamic event.">QF_newX_()</a> raises an assertion when the <code>margin</code> parameter is <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159" title="special value of margin that causes asserting failure in case event allocation or event posting fails">QF_NO_MARGIN</a> and allocation of the event turns out to be impossible due to event pool depletion, or incorrect (too big) size of the requested event.</dd>
<dd>
The application code should not call this function directly. The only allowed use is thorough the macros <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a> or <a class="el" href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436" title="Allocate a dynamic event (non-asserting version).">Q_NEW_X()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00164">164</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a4c87ff6aaac16a7327a7437c4e72be24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c87ff6aaac16a7327a7437c4e72be24">&#9670;&nbsp;</a></span>QF_newRef_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_evt.html">QEvt</a> const* QF_newRef_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>evtRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal QF implementation of creating new event reference. </p>
<dl class="section user"><dt>Description</dt><dd>Creates and returns a new reference to the current event e</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the current event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtRef</td><td>the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created reference to the event <code>e</code></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. The only allowed use is thorough the macro <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the event must be dynamic and the provided event reference must not be already in use</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00303">303</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="aebb373ddc448c4198e4247b6c6ff3e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb373ddc448c4198e4247b6c6ff3e69">&#9670;&nbsp;</a></span>QF_deleteRef_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_deleteRef_ </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>evtRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal QF implementation of deleting event reference. </p>
<dl class="section user"><dt>Description</dt><dd>Deletes an existing reference to the event e</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtRef</td><td>the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. The only allowed use is thorough the macro <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00338">338</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a7aa4e9d39b8af089405cb829e2cc5a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa4e9d39b8af089405cb829e2cc5a24">&#9670;&nbsp;</a></span>QF_gc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_gc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recycle a dynamic event. </p>
<dl class="section user"><dt>Description</dt><dd>This function implements a simple garbage collector for the dynamic events. Only dynamic events are candidates for recycling. (A dynamic event is one that is allocated from an event pool, which is determined as non-zero e-&gt;poolId_ attribute.) Next, the function decrements the reference counter of the event (e-&gt;refCtr_), and recycles the event only if the counter drops to zero (meaning that no more references are outstanding for this event). The dynamic event is recycled by returning it to the pool from which it was originally allocated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the event to recycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>QF invokes the garbage collector at all appropriate contexts, when an event can become garbage (automatic garbage collection), so the application code should have no need to call <a class="el" href="qf__dyn_8c.html#a7aa4e9d39b8af089405cb829e2cc5a24" title="Recycle a dynamic event.">QF_gc()</a> directly. The <a class="el" href="qf__dyn_8c.html#a7aa4e9d39b8af089405cb829e2cc5a24" title="Recycle a dynamic event.">QF_gc()</a> function is exposed only for special cases when your application sends dynamic events to the "raw" thread-safe queues (see <a class="el" href="qequeue_8h.html#struct_q_e_queue" title="Native QF Event Queue.">QEQueue</a>). Such queues are processed outside of QF and the automatic garbage collection is <b>NOT</b> performed for these events. In this case you need to call <a class="el" href="qf__dyn_8c.html#a7aa4e9d39b8af089405cb829e2cc5a24" title="Recycle a dynamic event.">QF_gc()</a> explicitly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00240">240</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a1e5f5f3c33ce2706283cbe8179a9a2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5f5f3c33ce2706283cbe8179a9a2c5">&#9670;&nbsp;</a></span>QF_bzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_bzero </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a specified region of memory to zero. </p>
<dl class="section user"><dt>Description</dt><dd>Clears a memory buffer by writing zeros byte-by-byte.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>pointer to the beginning of a memory buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the memory buffer to clear (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The main application of this function is clearing the internal QF variables upon startup. This is done to avoid problems with non-standard startup code provided with some compilers and toolsets (e.g., TI DSPs or Microchip MPLAB), which does not zero the uninitialized variables, as required by the ANSI C standard. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__act_8c_source.html#l00144">144</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

</div>
</div>
<a id="a3558503dacda5fe520ce300fce4627a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3558503dacda5fe520ce300fce4627a2">&#9670;&nbsp;</a></span>QTicker_ctor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QTicker_ctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_ticker.html">QTicker</a> *const&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="16bit_2stdint_8h.html#ad0906fbe05a45fbdb000c58fe8929e70">uint_fast8_t</a>&#160;</td>
          <td class="paramname"><em>tickRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="struct_q_ticker.html" title="QTicker Active Object class.">QTicker</a> Active Object class. </p>
<p>Constructor of the <a class="el" href="struct_q_ticker.html" title="QTicker Active Object class.">QTicker</a> Active Object class. </p>

<p class="definition">Definition at line <a class="el" href="qf__actq_8c_source.html#l00438">438</a> of file <a class="el" href="qf__actq_8c_source.html">qf_actq.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6ece34fc555ade0a6a10a259a6463401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ece34fc555ade0a6a10a259a6463401">&#9670;&nbsp;</a></span>QF_active_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_active.html">QActive</a>* QF_active_[<a class="el" href="qxk_2qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389">QF_MAX_ACTIVE</a>+1U]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array of registered active objects </p>
<dl class="section note"><dt>Note</dt><dd>Not to be used by Clients directly, only in ports of QF </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__act_8c_source.html#l00054">54</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aqpc_8h_html"><div class="ttname"><a href="qpc_8h.html">qpc.h</a></div><div class="ttdoc">QP/C public interface including backwards-compatibility layer.</div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_aba7bc1797add20fe3efdf37ced1182c5"><div class="ttname"><a href="16bit_2stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a></div><div class="ttdeci">unsigned char uint8_t</div><div class="ttdoc">exact-width 8-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00029">16bit/stdint.h:29</a></div></div>
<div class="ttc" id="aqassert_8h_html_a27042866331f49c9e9ff4f3ef459eaaf"><div class="ttname"><a href="qassert_8h.html#a27042866331f49c9e9ff4f3ef459eaaf">Q_DEFINE_THIS_FILE</a></div><div class="ttdeci">#define Q_DEFINE_THIS_FILE</div><div class="ttdoc">Define the file name (with __FILE__) for assertions in this file.</div><div class="ttdef"><b>Definition:</b> <a href="qassert_8h_source.html#l00104">qassert.h:104</a></div></div>
<div class="ttc" id="aqf_8h_html_a1c4fc5636c2bc2e9d47e958aac05b8e1"><div class="ttname"><a href="qf_8h.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a></div><div class="ttdeci">void QF_poolInit(void *const poolSto, uint_fast32_t const poolSize, uint_fast16_t const evtSize)</div><div class="ttdoc">Event pool initialization for dynamic allocation of events.</div><div class="ttdef"><b>Definition:</b> <a href="qf__dyn_8c_source.html#l00113">qf_dyn.c:113</a></div></div>
<div class="ttc" id="astruct_q_evt_html_a20b1ceebb91aea39fcbc633aeae6cd3f"><div class="ttname"><a href="struct_q_evt.html#a20b1ceebb91aea39fcbc633aeae6cd3f">QEvt::sig</a></div><div class="ttdeci">QSignal sig</div><div class="ttdoc">signal of the event instance</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00152">qep.h:152</a></div></div>
<div class="ttc" id="aqf_8h_html_aa52b4d3c43a262022392c6e11be06436"><div class="ttname"><a href="qf_8h.html#aa52b4d3c43a262022392c6e11be06436">Q_NEW_X</a></div><div class="ttdeci">#define Q_NEW_X(e_, evtT_, margin_, sig_)</div><div class="ttdoc">Allocate a dynamic event (non-asserting version).</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00787">qf.h:787</a></div></div>
<div class="ttc" id="aqf_8h_html_a779a1bc9482e2d489dc87751cd100fdb"><div class="ttname"><a href="qf_8h.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a></div><div class="ttdeci">int_t QF_run(void)</div><div class="ttdoc">Transfers control to QF to run the application.</div><div class="ttdef"><b>Definition:</b> <a href="qk_8c_source.html#l00133">qk.c:133</a></div></div>
<div class="ttc" id="astruct_q_active_html_a3123ef03f5d66d866da12c736ac574b0"><div class="ttname"><a href="struct_q_active.html#a3123ef03f5d66d866da12c736ac574b0">QActive::QACTIVE_START</a></div><div class="ttdeci">#define QACTIVE_START(me_, prio_, qSto_, qLen_, stkSto_, stkLen_, par_)</div><div class="ttdoc">Polymorphically start an active object.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00216">qf.h:216</a></div></div>
<div class="ttc" id="aqep_8h_html_a54b2da5e70ef983cfa7ca74deac237a3"><div class="ttname"><a href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3">Q_HANDLED</a></div><div class="ttdeci">#define Q_HANDLED()</div><div class="ttdoc">Macro to call in a state-handler when it handles an event.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00566">qep.h:566</a></div></div>
<div class="ttc" id="aqassert_8h_html_ad58d2c6dc25f8f0f764eb69faa79eee2"><div class="ttname"><a href="qassert_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a></div><div class="ttdeci">#define Q_DIM(array_)</div><div class="ttdoc">Helper macro to calculate static dimension of a 1-dim array_.</div><div class="ttdef"><b>Definition:</b> <a href="qassert_8h_source.html#l00337">qassert.h:337</a></div></div>
<div class="ttc" id="astruct_q_active_html"><div class="ttname"><a href="struct_q_active.html">QActive</a></div><div class="ttdoc">Active Object base class (based on QHsm implementation)</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00116">qf.h:116</a></div></div>
<div class="ttc" id="aqf_8h_html_a3a20b07a97300a74383cd863cbfd6bc6"><div class="ttname"><a href="qf_8h.html#a3a20b07a97300a74383cd863cbfd6bc6">QF_psInit</a></div><div class="ttdeci">void QF_psInit(QSubscrList *const subscrSto, enum_t const maxSignal)</div><div class="ttdoc">Publish-subscribe initialization.</div><div class="ttdef"><b>Definition:</b> <a href="qf__ps_8c_source.html#l00087">qf_ps.c:87</a></div></div>
<div class="ttc" id="aqep_8h_html_adf764cbdea00d65edcd07bb9953ad2b7ac286909dd59290d1076b51d4cfdfaefe"><div class="ttname"><a href="qep_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a></div><div class="ttdeci">@ Q_ENTRY_SIG</div><div class="ttdoc">signal for coding entry actions</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00702">qep.h:702</a></div></div>
<div class="ttc" id="aqf_8h_html_a3c1957439cb1ecff92be7b7401bf3159"><div class="ttname"><a href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a></div><div class="ttdeci">#define QF_NO_MARGIN</div><div class="ttdoc">special value of margin that causes asserting failure in case event allocation or event posting fails</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00687">qf.h:687</a></div></div>
<div class="ttc" id="astruct_q_active_html_a766856b24aa5163b7ca90bc3432f1e3e"><div class="ttname"><a href="struct_q_active.html#a766856b24aa5163b7ca90bc3432f1e3e">QActive::QACTIVE_POST_X</a></div><div class="ttdeci">#define QACTIVE_POST_X(me_, e_, margin_, sender_)</div><div class="ttdoc">Polymorphically posts an event to an active object (FIFO) without delivery guarantee.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00291">qf.h:291</a></div></div>
<div class="ttc" id="aqf_8h_html_adac7eccb860d910c4e446d3143798bba"><div class="ttname"><a href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a></div><div class="ttdeci">void QF_init(void)</div><div class="ttdoc">QF initialization.</div><div class="ttdef"><b>Definition:</b> <a href="qk_8c_source.html#l00072">qk.c:72</a></div></div>
<div class="ttc" id="aqep_8h_html_ad141f4e9efcba4613f82a8b2c76663ad"><div class="ttname"><a href="qep_8h.html#ad141f4e9efcba4613f82a8b2c76663ad">QState</a></div><div class="ttdeci">uint_fast8_t QState</div><div class="ttdoc">typedef of the return type from a state/action-handler function.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00204">qep.h:204</a></div></div>
<div class="ttc" id="aqf_8h_html_a1c49ff8c7895ca20958de54583a4e9cd"><div class="ttname"><a href="qf_8h.html#a1c49ff8c7895ca20958de54583a4e9cd">QF_newX_</a></div><div class="ttdeci">QEvt * QF_newX_(uint_fast16_t const evtSize, uint_fast16_t const margin, enum_t const sig)</div><div class="ttdoc">Internal QF implementation of creating new dynamic event.</div><div class="ttdef"><b>Definition:</b> <a href="qf__dyn_8c_source.html#l00164">qf_dyn.c:164</a></div></div>
<div class="ttc" id="aqs_8h_html_a034206ff7f20a4e6426a5f554434643b"><div class="ttname"><a href="qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a></div><div class="ttdeci">#define QS_OBJ_DICTIONARY(obj_)</div><div class="ttdoc">Output object dictionary record.</div><div class="ttdef"><b>Definition:</b> <a href="qs_8h_source.html#l00779">qs.h:779</a></div></div>
<div class="ttc" id="astruct_q_evt_html"><div class="ttname"><a href="struct_q_evt.html">QEvt</a></div><div class="ttdoc">Event class.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00151">qep.h:151</a></div></div>
<div class="ttc" id="astruct_q_hsm_html_ac8ae4728dfab5ce26a907fc624f6e104"><div class="ttname"><a href="struct_q_hsm.html#ac8ae4728dfab5ce26a907fc624f6e104">QHsm::QHsm_top</a></div><div class="ttdeci">QState QHsm_top(void const *const me, QEvt const *const e)</div><div class="ttdoc">the top-state.</div><div class="ttdef"><b>Definition:</b> <a href="qep__hsm_8c_source.html#l00248">qep_hsm.c:248</a></div></div>
<div class="ttc" id="aqf_8h_html_abd823f3a9e8b3206a3460a108d5fa3e3"><div class="ttname"><a href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a></div><div class="ttdeci">#define Q_NEW(evtT_, sig_)</div><div class="ttdoc">Allocate a dynamic event.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00756">qf.h:756</a></div></div>
<div class="ttc" id="aqep_8h_html_ad8abd2f7098c41ec464343d9d8f1eadc"><div class="ttname"><a href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc">Q_SUPER</a></div><div class="ttdeci">#define Q_SUPER(super_)</div><div class="ttdoc">Macro to call in a state-handler when it designates the superstate of a given state.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8h_source.html#l00560">qep.h:560</a></div></div>
<div class="ttc" id="aqk_2qf__port_8h_html_ad2d11956704ad838c9c954368d3d37d5"><div class="ttname"><a href="qk_2qf__port_8h.html#ad2d11956704ad838c9c954368d3d37d5">QF_INT_ENABLE</a></div><div class="ttdeci">#define QF_INT_ENABLE()</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8h_source.html#l00045">qk/qf_port.h:45</a></div></div>
<div class="ttc" id="aqk_2qf__port_8h_html_a88df5203e3a9716327b58923f5aaac80"><div class="ttname"><a href="qk_2qf__port_8h.html#a88df5203e3a9716327b58923f5aaac80">QF_INT_DISABLE</a></div><div class="ttdeci">#define QF_INT_DISABLE()</div><div class="ttdef"><b>Definition:</b> <a href="qk_2qf__port_8h_source.html#l00044">qk/qf_port.h:44</a></div></div>
<div class="ttc" id="aqf_8h_html_a1f1970e16f4d010b5e5b2fd046aac41e"><div class="ttname"><a href="qf_8h.html#a1f1970e16f4d010b5e5b2fd046aac41e">QF_TICK_X</a></div><div class="ttdeci">#define QF_TICK_X(tickRate_, sender_)</div><div class="ttdoc">Invoke the system clock tick processing QF_tickX_().</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00675">qf.h:675</a></div></div>
<div class="ttc" id="aqmpool_8h_html_ab0fe475154021674f904c52e61e78841"><div class="ttname"><a href="qmpool_8h.html#ab0fe475154021674f904c52e61e78841">QF_MPOOL_EL</a></div><div class="ttdeci">#define QF_MPOOL_EL(evType_)</div><div class="ttdoc">Memory pool element to allocate correctly aligned storage for QMPool class.</div><div class="ttdef"><b>Definition:</b> <a href="qmpool_8h_source.html#l00167">qmpool.h:167</a></div></div>
<div class="ttc" id="aqpset_8h_html_struct_q_p_set"><div class="ttname"><a href="qpset_8h.html#struct_q_p_set">QPSet</a></div><div class="ttdoc">Priority Set of up to 32 elements.</div><div class="ttdef"><b>Definition:</b> <a href="qpset_8h_source.html#l00068">qpset.h:68</a></div></div>
<div class="ttc" id="astruct_q_active_html_ab7c56990d949c8708e3fe2b737f2e65c"><div class="ttname"><a href="struct_q_active.html#ab7c56990d949c8708e3fe2b737f2e65c">QActive::QACTIVE_POST</a></div><div class="ttdeci">#define QACTIVE_POST(me_, e_, sender_)</div><div class="ttdoc">Polymorphically posts an event to an active object (FIFO) with delivery guarantee.</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00251">qf.h:251</a></div></div>
<div class="ttc" id="a16bit_2stdint_8h_html_a226d967fb6d06433caf43f20dc876aae"><div class="ttname"><a href="16bit_2stdint_8h.html#a226d967fb6d06433caf43f20dc876aae">uint_fast16_t</a></div><div class="ttdeci">unsigned int uint_fast16_t</div><div class="ttdoc">fast at-least 16-bit unsigned int</div><div class="ttdef"><b>Definition:</b> <a href="16bit_2stdint_8h_source.html#l00038">16bit/stdint.h:38</a></div></div>
<!-- start footer part -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
      <ul>
        <li class="navelem"><a class="el" href="dir_9b55b230f41344f00f9f1f35be51edc6.html">include</a></li><li class="navelem"><a class="el" href="qf_8h.html">qf.h</a></li>
        <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C 6.9.1</b>
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; Quantum Leaps 2020</a> &nbsp;| &nbsp; <a title="help" href="help.html">Using Online Help</a>&nbsp;| &nbsp;<a title="Doxygen" href="http://www.doxygen.nl">Generated with Doxygen</a>&nbsp; | &nbsp;<b>QP/C 6.9.1</b>
</small></address>
        </li>
      </ul>
    </div>
    <script src="custom.js"></script>
  </body>
</html>
